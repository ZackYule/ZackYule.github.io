<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://blog.zackyule.workers.dev/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.zackyule.workers.dev"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-图床测试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/24/%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95/" class="article-date">
  <time datetime="2020-04-24T03:08:43.223Z" itemprop="datePublished">2020-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/24/%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95/">图床测试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>图床测试</p>
<hr>
<p><img src="https://gitee.com/ZackYule/blogImage/raw/master/img/%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83.svg" alt="排序比较"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.zackyule.workers.dev/2020/04/24/%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95/" data-id="ck9dm8vmp0002ag0v8561envn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-t3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/22/t3/" class="article-date">
  <time datetime="2020-04-22T01:36:38.000Z" itemprop="datePublished">2020-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/22/t3/">t3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="排序比较.svg">排序比较</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.zackyule.workers.dev/2020/04/22/t3/" data-id="ck9dm8vmn0001ag0v1lkockjt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-test2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/22/test2/" class="article-date">
  <time datetime="2020-04-22T01:35:21.000Z" itemprop="datePublished">2020-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/22/test2/">test2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.zackyule.workers.dev/2020/04/22/test2/" data-id="ck9dm8vmr0004ag0vh8442zuv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-我的第二篇文章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/" class="article-date">
  <time datetime="2020-04-22T01:33:03.000Z" itemprop="datePublished">2020-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/">我的第二篇文章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.zackyule.workers.dev/2020/04/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/" data-id="ck9dm8vmt0006ag0v0r4iapk9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/22/hello-world/" class="article-date">
  <time datetime="2020-04-22T00:35:36.168Z" itemprop="datePublished">2020-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/22/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.zackyule.workers.dev/2020/04/22/hello-world/" data-id="ck9dm8vmj0000ag0v5o9p85ly" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-test" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/21/test/" class="article-date">
  <time datetime="2020-04-21T01:11:47.014Z" itemprop="datePublished">2020-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/21/test/">test</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="排序比较.svg">排序比较</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.zackyule.workers.dev/2020/04/21/test/" data-id="ck9dm8vmu0007ag0vfkjfgqiq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Js面试题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/21/Js%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2020-04-21T00:58:21.721Z" itemprop="datePublished">2020-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/21/Js%E9%9D%A2%E8%AF%95%E9%A2%98/">Js面试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Js面试题"><a href="#Js面试题" class="headerlink" title="Js面试题"></a>Js面试题</h1><h2 id="牛客"><a href="#牛客" class="headerlink" title="牛客"></a>牛客</h2><h3 id="判断数据类型typeof、instanceof、Object-prototype-toString-call-、constructor"><a href="#判断数据类型typeof、instanceof、Object-prototype-toString-call-、constructor" class="headerlink" title="判断数据类型typeof、instanceof、Object.prototype.toString.call()、constructor"></a>判断数据类型typeof、instanceof、Object.prototype.toString.call()、constructor</h3><h4 id="typeof-返回的类型都是字符串形式，可判断function的类型，在判断除Object类型的对象时比较方便"><a href="#typeof-返回的类型都是字符串形式，可判断function的类型，在判断除Object类型的对象时比较方便" class="headerlink" title="typeof 返回的类型都是字符串形式，可判断function的类型，在判断除Object类型的对象时比较方便"></a>typeof 返回的类型都是字符串形式，可判断function的类型，在判断除Object类型的对象时比较方便</h4><h5 id="var-a-“ing-”-var-b-111-var-c-1-2-3-4-var-d-new-Date-var-e-function-alert-111"><a href="#var-a-“ing-”-var-b-111-var-c-1-2-3-4-var-d-new-Date-var-e-function-alert-111" class="headerlink" title="var a = “ing.”; var b = 111; var c= [1,2,3,4]; var d = new Date(); var e = function(){alert(111);};"></a>var a = “ing.”; var b = 111; var c= [1,2,3,4]; var d = new Date(); var e = function(){alert(111);};</h5><h6 id="result-typeof-a-string-result-typeof-b-number-result-typeof-c-object-result-typeof-d-object-result-typeof-e-function"><a href="#result-typeof-a-string-result-typeof-b-number-result-typeof-c-object-result-typeof-d-object-result-typeof-e-function" class="headerlink" title="result(typeof a); // string result(typeof b); // number result(typeof c); // object result(typeof d); // object result(typeof e); // function"></a>result(typeof a); // string result(typeof b); // number result(typeof c); // object result(typeof d); // object result(typeof e); // function</h6><h5 id="null得到的结果是object"><a href="#null得到的结果是object" class="headerlink" title="null得到的结果是object"></a>null得到的结果是object</h5><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><h6 id="xx-instanceOf-String"><a href="#xx-instanceOf-String" class="headerlink" title="xx instanceOf String"></a>xx instanceOf String</h6><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><h6 id="既是对象也是数组，字符串…"><a href="#既是对象也是数组，字符串…" class="headerlink" title="既是对象也是数组，字符串…"></a>既是对象也是数组，字符串…</h6><h4 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h4><h5 id="通用很繁琐"><a href="#通用很繁琐" class="headerlink" title="通用很繁琐"></a>通用很繁琐</h5><h6 id="result-Object-prototype-toString-call-a-‘-object-String-‘-true-result-Object-prototype-toString-call-b-‘-object-Number-‘-true-result-Object-prototype-toString-call-c-‘-object-Array-‘-true-result-Object-prototype-toString-call-d-‘-object-Date-‘-true-result-Object-prototype-toString-call-e-‘-object-Function-‘-true"><a href="#result-Object-prototype-toString-call-a-‘-object-String-‘-true-result-Object-prototype-toString-call-b-‘-object-Number-‘-true-result-Object-prototype-toString-call-c-‘-object-Array-‘-true-result-Object-prototype-toString-call-d-‘-object-Date-‘-true-result-Object-prototype-toString-call-e-‘-object-Function-‘-true" class="headerlink" title="result(Object.prototype.toString.call(a) === ‘[object String]‘); // true; result(Object.prototype.toString.call(b) === ‘[object Number]‘); // true; result(Object.prototype.toString.call(c) === ‘[object Array]‘); // true; result(Object.prototype.toString.call(d) === ‘[object Date]‘); // true; result(Object.prototype.toString.call(e) === ‘[object Function]‘); // true;"></a>result(Object.prototype.toString.call(a) === ‘[object String]‘); // true; result(Object.prototype.toString.call(b) === ‘[object Number]‘); // true; result(Object.prototype.toString.call(c) === ‘[object Array]‘); // true; result(Object.prototype.toString.call(d) === ‘[object Date]‘); // true; result(Object.prototype.toString.call(e) === ‘[object Function]‘); // true;</h6><h4 id="constructor-这个属性在类继承时会出错"><a href="#constructor-这个属性在类继承时会出错" class="headerlink" title="constructor 这个属性在类继承时会出错"></a>constructor 这个属性在类继承时会出错</h4><h3 id="类数组与数组的区别与转换"><a href="#类数组与数组的区别与转换" class="headerlink" title="类数组与数组的区别与转换"></a>类数组与数组的区别与转换</h3><h4 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h4><h5 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h5><h6 id="所谓类似数组的对象，本质特征只有一点，即必须有length属性"><a href="#所谓类似数组的对象，本质特征只有一点，即必须有length属性" class="headerlink" title="所谓类似数组的对象，本质特征只有一点，即必须有length属性"></a>所谓类似数组的对象，本质特征只有一点，即必须有length属性</h6><p>####### array-like object就是实现了部分array接口的object</p>
<p>####### 这跟让一个class实现一个Iterator接口是十分类似的</p>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><h6 id="拥有length属性，可以使用下标来访问元素，这两点和数组相同"><a href="#拥有length属性，可以使用下标来访问元素，这两点和数组相同" class="headerlink" title="拥有length属性，可以使用下标来访问元素，这两点和数组相同"></a>拥有length属性，可以使用下标来访问元素，这两点和数组相同</h6><h6 id="不能使用数组的方法，他们不能使用Array的方法"><a href="#不能使用数组的方法，他们不能使用Array的方法" class="headerlink" title="不能使用数组的方法，他们不能使用Array的方法"></a>不能使用数组的方法，他们不能使用Array的方法</h6><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><h6 id="对console输出更友好，简单说就是更直观"><a href="#对console输出更友好，简单说就是更直观" class="headerlink" title="对console输出更友好，简单说就是更直观"></a>对console输出更友好，简单说就是更直观</h6><h6 id="有的时候，数组是不够用的，我们可能还要存一些元数据在这个数组上，或者有些对这个数组每个元素适用的方法"><a href="#有的时候，数组是不够用的，我们可能还要存一些元数据在这个数组上，或者有些对这个数组每个元素适用的方法" class="headerlink" title="有的时候，数组是不够用的，我们可能还要存一些元数据在这个数组上，或者有些对这个数组每个元素适用的方法"></a>有的时候，数组是不够用的，我们可能还要存一些元数据在这个数组上，或者有些对这个数组每个元素适用的方法</h6><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><h6 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h6><p>####### js原生的数组（注意是做数组用的，function什么的不算）除了arguments外基本是真数组</p>
<h6 id="浏览器根据规范实现的-使用-querySelectorAll-选择到的元素集合-HTMLCollection"><a href="#浏览器根据规范实现的-使用-querySelectorAll-选择到的元素集合-HTMLCollection" class="headerlink" title="浏览器根据规范实现的. 使用 querySelectorAll 选择到的元素集合 [ HTMLCollection ]"></a>浏览器根据规范实现的. 使用 querySelectorAll 选择到的元素集合 [ HTMLCollection ]</h6><p>####### DOM相关的数组基本都是类数组，如window（length属性是frame/iframe数量） storage(比如localStorage、sessionStorage，length属性是里面存的数据的条数，说起来这能算数组吗……)</p>
<h6 id="node-childNodes-NodeList"><a href="#node-childNodes-NodeList" class="headerlink" title="node.childNodes [ NodeList ]"></a>node.childNodes [ NodeList ]</h6><h6 id="string-String-prototype-function（length属性是参数个数）-Function-prototype-各种TypedArray（如Int8Array）"><a href="#string-String-prototype-function（length属性是参数个数）-Function-prototype-各种TypedArray（如Int8Array）" class="headerlink" title="string String.prototype function（length属性是参数个数） Function.prototype 各种TypedArray（如Int8Array）"></a>string String.prototype function（length属性是参数个数） Function.prototype 各种TypedArray（如Int8Array）</h6><h4 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h4><h5 id="扩展运算符还可以将字符串转为真正的数组"><a href="#扩展运算符还可以将字符串转为真正的数组" class="headerlink" title="扩展运算符还可以将字符串转为真正的数组"></a>扩展运算符还可以将字符串转为真正的数组</h5><h6 id="…’hello’-“h”-“e”-“l”-“l”-“o”"><a href="#…’hello’-“h”-“e”-“l”-“l”-“o”" class="headerlink" title="[…’hello’] // [ “h”, “e”, “l”, “l”, “o” ]"></a>[…’hello’] // [ “h”, “e”, “l”, “l”, “o” ]</h6><h5 id="ES5的写法-var-arr1-slice-call-arrayLike-‘a’-‘b’-‘c’"><a href="#ES5的写法-var-arr1-slice-call-arrayLike-‘a’-‘b’-‘c’" class="headerlink" title="// ES5的写法 var arr1 = [].slice.call(arrayLike); // [‘a’, ‘b’, ‘c’]"></a>// ES5的写法 var arr1 = [].slice.call(arrayLike); // [‘a’, ‘b’, ‘c’]</h5><h6 id="var-arr-Array-prototype-slice-call-arguments"><a href="#var-arr-Array-prototype-slice-call-arguments" class="headerlink" title="var arr = Array.prototype.slice.call(arguments);"></a>var arr = Array.prototype.slice.call(arguments);</h6><h5 id="Array-from方法用于将两类对象转为真正的数组"><a href="#Array-from方法用于将两类对象转为真正的数组" class="headerlink" title="Array.from方法用于将两类对象转为真正的数组"></a>Array.from方法用于将两类对象转为真正的数组</h5><h6 id="类似数组的对象（array-like-object）"><a href="#类似数组的对象（array-like-object）" class="headerlink" title="类似数组的对象（array-like object）"></a>类似数组的对象（array-like object）</h6><p>####### // ES6的写法 let arr2 = Array.from(arrayLike); // [‘a’, ‘b’, ‘c’]</p>
<h6 id="可遍历（iterable）的对象（包括-ES6-新增的数据结构-Set-和-Map）"><a href="#可遍历（iterable）的对象（包括-ES6-新增的数据结构-Set-和-Map）" class="headerlink" title="可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）"></a>可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）</h6><h3 id="bind、call、apply的区别"><a href="#bind、call、apply的区别" class="headerlink" title="bind、call、apply的区别"></a>bind、call、apply的区别</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><h5 id="bind，call，apply的作用都是用来改变this指向的"><a href="#bind，call，apply的作用都是用来改变this指向的" class="headerlink" title="bind，call，apply的作用都是用来改变this指向的"></a>bind，call，apply的作用都是用来改变this指向的</h5><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><h5 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h5><h6 id="第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入"><a href="#第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入" class="headerlink" title="第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入"></a>第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入</h6><p>####### 类数组也可以</p>
<h6 id="且当第一个参数为null、undefined的时候，默认指向window-在浏览器中"><a href="#且当第一个参数为null、undefined的时候，默认指向window-在浏览器中" class="headerlink" title="且当第一个参数为null、undefined的时候，默认指向window(在浏览器中)"></a>且当第一个参数为null、undefined的时候，默认指向window(在浏览器中)</h6><h5 id="call"><a href="#call" class="headerlink" title="call"></a>call</h5><h6 id="call方法的第一个参数也是this的指向，后面传入的是一个参数列表（注意和apply传参的区别）"><a href="#call方法的第一个参数也是this的指向，后面传入的是一个参数列表（注意和apply传参的区别）" class="headerlink" title="call方法的第一个参数也是this的指向，后面传入的是一个参数列表（注意和apply传参的区别）"></a>call方法的第一个参数也是this的指向，后面传入的是一个参数列表（注意和apply传参的区别）</h6><h6 id="当一个参数为null或undefined的时候，表示指向window（在浏览器中），和apply一样"><a href="#当一个参数为null或undefined的时候，表示指向window（在浏览器中），和apply一样" class="headerlink" title="当一个参数为null或undefined的时候，表示指向window（在浏览器中），和apply一样"></a>当一个参数为null或undefined的时候，表示指向window（在浏览器中），和apply一样</h6><h5 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h5><h6 id="和call很相似"><a href="#和call很相似" class="headerlink" title="和call很相似"></a>和call很相似</h6><p>####### 后面传入的也是一个参数列表(但是这个参数列表可以分多次传入，call则必须一次性传入所有参数)</p>
<p>######## 即后边执行时还可以传参</p>
<h6 id="但是它改变this指向后不会立即执行，而是返回一个永久改变this指向的函数"><a href="#但是它改变this指向后不会立即执行，而是返回一个永久改变this指向的函数" class="headerlink" title="但是它改变this指向后不会立即执行，而是返回一个永久改变this指向的函数"></a>但是它改变this指向后不会立即执行，而是返回一个永久改变this指向的函数</h6><h3 id="实现bind方法"><a href="#实现bind方法" class="headerlink" title="实现bind方法"></a>实现bind方法</h3><h4 id="简易版"><a href="#简易版" class="headerlink" title="简易版"></a>简易版</h4><h5 id="Function-prototype-bind-function-var-this-this-var-context-arguments-0-var-arg-slice-call-arguments-1-return-function-arg-concat-apply-arg-arguments-this-apply-context-arg"><a href="#Function-prototype-bind-function-var-this-this-var-context-arguments-0-var-arg-slice-call-arguments-1-return-function-arg-concat-apply-arg-arguments-this-apply-context-arg" class="headerlink" title="Function.prototype.bind=function () { var _this=this; var context=arguments[0]; var arg=[].slice.call(arguments,1); return function(){ arg=[].concat.apply(arg,arguments); _this.apply(context,arg); } };"></a>Function.prototype.bind=function () { var _this=this; var context=arguments[0]; var arg=[].slice.call(arguments,1); return function(){ arg=[].concat.apply(arg,arguments); _this.apply(context,arg); } };</h5><h4 id="完美版"><a href="#完美版" class="headerlink" title="完美版"></a>完美版</h4><h3 id="new的原理"><a href="#new的原理" class="headerlink" title="new的原理"></a>new的原理</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><h5 id="1-创建一个新的空对象，对象类型为简单的object"><a href="#1-创建一个新的空对象，对象类型为简单的object" class="headerlink" title="1. 创建一个新的空对象，对象类型为简单的object"></a>1. 创建一个新的空对象，对象类型为简单的object</h5><h5 id="2-设置这个空对象的实例原型-内部的、不可访问的-prototype-属性，部分浏览器可通过-proto-进行访问，ES5开始可通过-Object-getPrototypeOf-obj-取得-为构造函数的-prototype-属性（每个函数对象都拥有一个-prototype-属性）"><a href="#2-设置这个空对象的实例原型-内部的、不可访问的-prototype-属性，部分浏览器可通过-proto-进行访问，ES5开始可通过-Object-getPrototypeOf-obj-取得-为构造函数的-prototype-属性（每个函数对象都拥有一个-prototype-属性）" class="headerlink" title="2. 设置这个空对象的实例原型(内部的、不可访问的[[prototype]]属性，部分浏览器可通过`__proto__`进行访问，ES5开始可通过`Object.getPrototypeOf(obj)`取得)为构造函数的`prototype`属性（每个函数对象都拥有一个`prototype`属性）"></a>2. 设置这个空对象的实例原型(内部的、不可访问的[[prototype]]属性，部分浏览器可通过`__proto__`进行访问，ES5开始可通过`Object.getPrototypeOf(obj)`取得)为构造函数的`prototype`属性（每个函数对象都拥有一个`prototype`属性）</h5><h5 id="3-让-this-变量指向这个新创建的对象"><a href="#3-让-this-变量指向这个新创建的对象" class="headerlink" title="3. 让`this`变量指向这个新创建的对象"></a>3. 让`this`变量指向这个新创建的对象</h5><h5 id="4-以这个新创建的对象为上下文执行构造函数"><a href="#4-以这个新创建的对象为上下文执行构造函数" class="headerlink" title="4. 以这个新创建的对象为上下文执行构造函数"></a>4. 以这个新创建的对象为上下文执行构造函数</h5><h5 id="5-如果构造函数有返回非空的对象，则返回该对象，否则返回第一步中创建的对象。"><a href="#5-如果构造函数有返回非空的对象，则返回该对象，否则返回第一步中创建的对象。" class="headerlink" title="5. 如果构造函数有返回非空的对象，则返回该对象，否则返回第一步中创建的对象。"></a>5. 如果构造函数有返回非空的对象，则返回该对象，否则返回第一步中创建的对象。</h5><h3 id="如何正确判断this？"><a href="#如何正确判断this？" class="headerlink" title="如何正确判断this？"></a>如何正确判断this？</h3><h4 id="在ES5下"><a href="#在ES5下" class="headerlink" title="在ES5下"></a>在ES5下</h4><h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><h6 id="函数是否是bind方法返回的？若是，则this指向指定对象。"><a href="#函数是否是bind方法返回的？若是，则this指向指定对象。" class="headerlink" title="函数是否是bind方法返回的？若是，则this指向指定对象。"></a>函数是否是bind方法返回的？若是，则this指向指定对象。</h6><h6 id="函数是否通过apply-call调用？若是，则this指向指定对象。"><a href="#函数是否通过apply-call调用？若是，则this指向指定对象。" class="headerlink" title="函数是否通过apply/call调用？若是，则this指向指定对象。"></a>函数是否通过apply/call调用？若是，则this指向指定对象。</h6><h6 id="函数是否是new调用？若是，则this指向新对象"><a href="#函数是否是new调用？若是，则this指向新对象" class="headerlink" title="函数是否是new调用？若是，则this指向新对象"></a>函数是否是new调用？若是，则this指向新对象</h6><h6 id="是否作为对象的方法调用？若是，则this指向该对象"><a href="#是否作为对象的方法调用？若是，则this指向该对象" class="headerlink" title="是否作为对象的方法调用？若是，则this指向该对象"></a>是否作为对象的方法调用？若是，则this指向该对象</h6><h6 id="this指向全局"><a href="#this指向全局" class="headerlink" title="this指向全局"></a>this指向全局</h6><h3 id="闭包及其作用"><a href="#闭包及其作用" class="headerlink" title="闭包及其作用"></a>闭包及其作用</h3><h4 id="本质-1"><a href="#本质-1" class="headerlink" title="本质"></a>本质</h4><h5 id="闭包是函数内部的一个函数"><a href="#闭包是函数内部的一个函数" class="headerlink" title="闭包是函数内部的一个函数"></a>闭包是函数内部的一个函数</h5><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><h5 id="可以创建出公共的方法来访问或者改变函数中私有的变量，等于是getter或者是setter方法"><a href="#可以创建出公共的方法来访问或者改变函数中私有的变量，等于是getter或者是setter方法" class="headerlink" title="可以创建出公共的方法来访问或者改变函数中私有的变量，等于是getter或者是setter方法"></a>可以创建出公共的方法来访问或者改变函数中私有的变量，等于是getter或者是setter方法</h5><h5 id="可以让这些变量一直在内存中保存（如果使用不当，容易造成内存泄漏）"><a href="#可以让这些变量一直在内存中保存（如果使用不当，容易造成内存泄漏）" class="headerlink" title="可以让这些变量一直在内存中保存（如果使用不当，容易造成内存泄漏）"></a>可以让这些变量一直在内存中保存（如果使用不当，容易造成内存泄漏）</h5><h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><h5 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h5><h6 id="最普通的对象：有-proto-属性（指向其原型链），没有prototype属性。"><a href="#最普通的对象：有-proto-属性（指向其原型链），没有prototype属性。" class="headerlink" title="最普通的对象：有__proto__属性（指向其原型链），没有prototype属性。"></a>最普通的对象：有__proto__属性（指向其原型链），没有prototype属性。</h6><h6 id="原型对象-Person-prototype-原型对象还有constructor属性（指向构造函数对象）"><a href="#原型对象-Person-prototype-原型对象还有constructor属性（指向构造函数对象）" class="headerlink" title="原型对象(Person.prototype 原型对象还有constructor属性（指向构造函数对象）)"></a>原型对象(Person.prototype 原型对象还有constructor属性（指向构造函数对象）)</h6><h5 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h5><h6 id="凡是通过new-Function-创建的都是函数对象"><a href="#凡是通过new-Function-创建的都是函数对象" class="headerlink" title="凡是通过new Function()创建的都是函数对象"></a>凡是通过new Function()创建的都是函数对象</h6><h6 id="拥有-proto-、prototype属性（指向原型对象）"><a href="#拥有-proto-、prototype属性（指向原型对象）" class="headerlink" title="拥有__proto__、prototype属性（指向原型对象）"></a>拥有__proto__、prototype属性（指向原型对象）</h6><h4 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h4><h5 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h5><h6 id="原型对象属于普通对象"><a href="#原型对象属于普通对象" class="headerlink" title="原型对象属于普通对象"></a>原型对象属于普通对象</h6><h5 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h5><h6 id="原型对象是包含特定类型的所有实例共享的属性和方法"><a href="#原型对象是包含特定类型的所有实例共享的属性和方法" class="headerlink" title="原型对象是包含特定类型的所有实例共享的属性和方法"></a>原型对象是包含特定类型的所有实例共享的属性和方法</h6><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><h6 id="原型对象的好处是，可以让所有实例对象共享它所包含的属性和方法"><a href="#原型对象的好处是，可以让所有实例对象共享它所包含的属性和方法" class="headerlink" title="原型对象的好处是，可以让所有实例对象共享它所包含的属性和方法"></a>原型对象的好处是，可以让所有实例对象共享它所包含的属性和方法</h6><h4 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h4><h5 id="Function-prototype是个例外，它是原型对象，却又是函数对象"><a href="#Function-prototype是个例外，它是原型对象，却又是函数对象" class="headerlink" title="Function.prototype是个例外，它是原型对象，却又是函数对象"></a>Function.prototype是个例外，它是原型对象，却又是函数对象</h5><h6 id="作为一个函数对象，它又没有prototype属性"><a href="#作为一个函数对象，它又没有prototype属性" class="headerlink" title="作为一个函数对象，它又没有prototype属性"></a>作为一个函数对象，它又没有prototype属性</h6><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h5 id="广义"><a href="#广义" class="headerlink" title="广义"></a>广义</h5><h6 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h6><p>####### 接口继承：只继承方法签名</p>
<p>####### 实现继承：继承实际的方法</p>
<p>######## 在ECMAScript中无法实现接口继承，只支持实现继承</p>
<h3 id="prototype与-proto-的关系与区别"><a href="#prototype与-proto-的关系与区别" class="headerlink" title="prototype与__proto__的关系与区别"></a>prototype与__proto__的关系与区别</h3><h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><h6 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h6><p>####### ObjectBase</p>
<p>######## 构造函数</p>
<p>######### Object</p>
<h5 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h5><h6 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h6><p>####### 示例</p>
<p>######## function Person(name, age, job){ var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function(){ alert(this.name); }; return o; } var friend = new Person(“Nicholas”, 29, “Software Engineer”);</p>
<p>######### function SpecialArray(){ //create the array var values = new Array(); //add the values values.push.apply(values, arguments); //assign the method values.toPipedString = function(){ return this.join(“|“); }; //return it return values; } var colors = new SpecialArray(“red”, “blue”, “green”);</p>
<p>####### 说明</p>
<p>######## 原型</p>
<p>######### 寄生的原型</p>
<p>########## 构造函数</p>
<p>########### 寄生的构造函数</p>
<h6 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h6><p>####### 辨析</p>
<p>######## 稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同</p>
<p>######### 一是新创建对象的实例方法不引用 this</p>
<p>######### 二是不使用 new 操作符调用构造函数</p>
<p>####### 示例</p>
<p>######## function Person(name, age, job){ var o = new Object(); o.sayName = function(){ alert(name); }; return o; } var friend = Person(“Nicholas”, 29, “Software Engineer”);</p>
<h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><h6 id="原型-1"><a href="#原型-1" class="headerlink" title="原型"></a>原型</h6><p>####### circleBase</p>
<h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6><p>####### CreateCircle</p>
<p>######## 原型</p>
<p>######### ObjectBase</p>
<p>########## 构造函数</p>
<p>########### Object</p>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><h6 id="不使用-new-操作符调用-Person-会出现什么结果"><a href="#不使用-new-操作符调用-Person-会出现什么结果" class="headerlink" title="不使用 new 操作符调用 Person()会出现什么结果"></a>不使用 new 操作符调用 Person()会出现什么结果</h6><p>####### 属性和方法都被添加给 window 对象了</p>
<h6 id="最后，也可以使用-call-（或者-apply-）在某个特殊对象的作用域中调用-Person-函数"><a href="#最后，也可以使用-call-（或者-apply-）在某个特殊对象的作用域中调用-Person-函数" class="headerlink" title="最后，也可以使用 call ()（或者 apply()）在某个特殊对象的作用域中调用 Person()函数"></a>最后，也可以使用 call ()（或者 apply()）在某个特殊对象的作用域中调用 Person()函数</h6><p>####### 这里是在对象的作用域中调用的，因此调用后</p>
<p>######## 就拥有了所有属性和 sayName() 方法</p>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><h6 id="不使用new也可以执行"><a href="#不使用new也可以执行" class="headerlink" title="不使用new也可以执行"></a>不使用new也可以执行</h6><p>####### if (this instanceof create) { return new this[type](param); } else { return new create(type, param); }</p>
<h5 id="发展-1"><a href="#发展-1" class="headerlink" title="发展"></a>发展</h5><h6 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h6><p>####### function Person(name, age, job){ //properties this.name = name; this.age = age; this.job = job; //methods if (typeof this.sayName != “function”){ Person.prototype.sayName = function(){ alert(this.name); }; } }</p>
<p>######## 这段代码只会在初次调用构造函数时オ会执行</p>
<p>######## 此后，原型已经完成初始化，不需要再做什么修改了</p>
<h3 id="继承的实现方式及比较"><a href="#继承的实现方式及比较" class="headerlink" title="继承的实现方式及比较"></a>继承的实现方式及比较</h3><h4 id="对象式继承"><a href="#对象式继承" class="headerlink" title="对象式继承"></a>对象式继承</h4><h5 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h5><h6 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h6><p>####### Object.create()</p>
<p>######## function object(o){ function F(){} F.prototype = o; return new F(); }</p>
<h6 id="适用"><a href="#适用" class="headerlink" title="适用"></a>适用</h6><p>####### 直接从 父类对象/基类 创建对象</p>
<h6 id="发展-2"><a href="#发展-2" class="headerlink" title="发展"></a>发展</h6><p>####### 寄生继承</p>
<p>######## 模式</p>
<p>######### function createAnother(original) { var clone = object(original); clone.sayHi = function(){ alert(“hi”); }; return clone; }</p>
<h4 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h4><h5 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h5><h6 id="模式-1"><a href="#模式-1" class="headerlink" title="模式"></a>模式</h6><p>####### function inheritPrototype(subType, superType){ var prototype = object(superType.prototype); //create object prototype.constructor = subType; //augment object subType.prototype = prototype; //assign object }</p>
<h5 id="构造函数继承-1"><a href="#构造函数继承-1" class="headerlink" title="构造函数继承"></a>构造函数继承</h5><h6 id="模式-2"><a href="#模式-2" class="headerlink" title="模式"></a>模式</h6><p>####### function SubType(){ SuperType.call(this, “Nicholas”);</p>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><p>####### 构造函数继承问题不能继承父构造函数的原型方法</p>
<h5 id="类式继承-原型链继承"><a href="#类式继承-原型链继承" class="headerlink" title="类式继承/原型链继承"></a>类式继承/原型链继承</h5><h6 id="模式-3"><a href="#模式-3" class="headerlink" title="模式"></a>模式</h6><p>####### SubType.prototype = new SuperType();</p>
<h6 id="发展-3"><a href="#发展-3" class="headerlink" title="发展"></a>发展</h6><p>####### 组合继承</p>
<p>######## 说明</p>
<p>######### 结合类式继承和构造函数继承</p>
<p>######## 缺点</p>
<p>######### __proto_里面的属性没有用</p>
<p>######### 执行了两次父构造函数</p>
<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><p>####### 这种方法不支持父构造函数带修数</p>
<p>####### 父构造函数里的方法和属性都会变成共有属性</p>
<h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><h5 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h5><h6 id="其实是为了防止一个函数在段时间内疯狂执行"><a href="#其实是为了防止一个函数在段时间内疯狂执行" class="headerlink" title="其实是为了防止一个函数在段时间内疯狂执行"></a>其实是为了防止一个函数在段时间内疯狂执行</h6><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><h6 id="搜索框-input事件；"><a href="#搜索框-input事件；" class="headerlink" title="搜索框 input事件；"></a>搜索框 input事件；</h6><h6 id="鼠标移动-mousemove事件；"><a href="#鼠标移动-mousemove事件；" class="headerlink" title="鼠标移动 mousemove事件；"></a>鼠标移动 mousemove事件；</h6><h6 id="视窗大小变化-resize事件；"><a href="#视窗大小变化-resize事件；" class="headerlink" title="视窗大小变化 resize事件；"></a>视窗大小变化 resize事件；</h6><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><h6 id="不希望某个事件在短时间内疯狂触发，影响性能"><a href="#不希望某个事件在短时间内疯狂触发，影响性能" class="headerlink" title="不希望某个事件在短时间内疯狂触发，影响性能"></a>不希望某个事件在短时间内疯狂触发，影响性能</h6><p>####### 所以我们设置一个定时器，让这个事件在一定时间延迟后再执行</p>
<p>####### 如果这个延迟中间中途这个事件又触发了，那就把上次事件绑定的定时器取消，避免了上次事件执行</p>
<p>######## 然后重新设置一个定时器绑定在当前事件上</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><h5 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h5><h6 id="目的很明确，就是节省流量"><a href="#目的很明确，就是节省流量" class="headerlink" title="目的很明确，就是节省流量"></a>目的很明确，就是节省流量</h6><p>####### 如果一个方法在短时间内疯狂执行，我们希望它每隔一段时间执行</p>
<h5 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h5><h6 id="懒加载时请求数据，在频繁滑动的时候，不会疯狂请求接口，减小对服务器的压力"><a href="#懒加载时请求数据，在频繁滑动的时候，不会疯狂请求接口，减小对服务器的压力" class="headerlink" title="懒加载时请求数据，在频繁滑动的时候，不会疯狂请求接口，减小对服务器的压力"></a>懒加载时请求数据，在频繁滑动的时候，不会疯狂请求接口，减小对服务器的压力</h6><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><h3 id="作用域和作用域链、执行期上下文"><a href="#作用域和作用域链、执行期上下文" class="headerlink" title="作用域和作用域链、执行期上下文"></a>作用域和作用域链、执行期上下文</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h5 id="变量对象-缩写为VO-是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容"><a href="#变量对象-缩写为VO-是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容" class="headerlink" title="变量对象(缩写为VO)是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容"></a>变量对象(缩写为VO)是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容</h5><h6 id="变量-var"><a href="#变量-var" class="headerlink" title="变量 (var)"></a>变量 (var)</h6><h6 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h6><h6 id="函数的形参"><a href="#函数的形参" class="headerlink" title="函数的形参"></a>函数的形参</h6><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><h5 id="全局上下文的的作用域链为GO，函数的执行上下文由自身的-scope-与活动对象的拼接而成"><a href="#全局上下文的的作用域链为GO，函数的执行上下文由自身的-scope-与活动对象的拼接而成" class="headerlink" title="全局上下文的的作用域链为GO，函数的执行上下文由自身的[[scope]]与活动对象的拼接而成"></a>全局上下文的的作用域链为GO，函数的执行上下文由自身的[[scope]]与活动对象的拼接而成</h5><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><h5 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h5><h6 id="JavaScript在解析至一段可执行代码的时候便会创建一个执行期上下文"><a href="#JavaScript在解析至一段可执行代码的时候便会创建一个执行期上下文" class="headerlink" title="JavaScript在解析至一段可执行代码的时候便会创建一个执行期上下文"></a>JavaScript在解析至一段可执行代码的时候便会创建一个执行期上下文</h6><p>####### 前者主要包括三种情况：全局代码，函数代码以及eval代码</p>
<h5 id="全局代码"><a href="#全局代码" class="headerlink" title="全局代码"></a>全局代码</h5><h6 id="在执行全局代码（script标签内）的时候，JavaScript创建全局上下文，全局上下文被压入执行上下文栈"><a href="#在执行全局代码（script标签内）的时候，JavaScript创建全局上下文，全局上下文被压入执行上下文栈" class="headerlink" title="在执行全局代码（script标签内）的时候，JavaScript创建全局上下文，全局上下文被压入执行上下文栈"></a>在执行全局代码（script标签内）的时候，JavaScript创建全局上下文，全局上下文被压入执行上下文栈</h6><h6 id="然后全局上下文进行初始化"><a href="#然后全局上下文进行初始化" class="headerlink" title="然后全局上下文进行初始化"></a>然后全局上下文进行初始化</h6><h6 id="在全局上下文中，它的变量对象（VO）即为全局对象（GO）自身"><a href="#在全局上下文中，它的变量对象（VO）即为全局对象（GO）自身" class="headerlink" title="在全局上下文中，它的变量对象（VO）即为全局对象（GO）自身"></a>在全局上下文中，它的变量对象（VO）即为全局对象（GO）自身</h6><p>####### 它的作用域链只包括自身的变量对象（VO）</p>
<h5 id="函数代码"><a href="#函数代码" class="headerlink" title="函数代码"></a>函数代码</h5><h6 id="在创建一个函数的时候，函数的-scope-属性便被创建"><a href="#在创建一个函数的时候，函数的-scope-属性便被创建" class="headerlink" title="在创建一个函数的时候，函数的[[scope]]属性便被创建"></a>在创建一个函数的时候，函数的[[scope]]属性便被创建</h6><p>####### 不管函数是否被调用，这个属性都会跟随这个函数永久存在，直至它被销毁或者程序结束</p>
<p>####### [[scope]]意为所有父变量对象的层级链</p>
<h6 id="在函数被执行（调用）的时候，函数的执行期上下文被创建，这个函数上下文被压入执行上下文栈"><a href="#在函数被执行（调用）的时候，函数的执行期上下文被创建，这个函数上下文被压入执行上下文栈" class="headerlink" title="在函数被执行（调用）的时候，函数的执行期上下文被创建，这个函数上下文被压入执行上下文栈"></a>在函数被执行（调用）的时候，函数的执行期上下文被创建，这个函数上下文被压入执行上下文栈</h6><h6 id="函数的变量对象是这个函数的活动对象，包括函数的形参，变量声明以及函数声明"><a href="#函数的变量对象是这个函数的活动对象，包括函数的形参，变量声明以及函数声明" class="headerlink" title="函数的变量对象是这个函数的活动对象，包括函数的形参，变量声明以及函数声明"></a>函数的变量对象是这个函数的活动对象，包括函数的形参，变量声明以及函数声明</h6><p>####### 函数的作用域链由自身的[[scope]]与活动对象拼接而成</p>
<h6 id="在函数执行完毕后，函数的执行期上下文以及活动对象被删除，函数的执行上下文从执行上下文栈中弹出"><a href="#在函数执行完毕后，函数的执行期上下文以及活动对象被删除，函数的执行上下文从执行上下文栈中弹出" class="headerlink" title="在函数执行完毕后，函数的执行期上下文以及活动对象被删除，函数的执行上下文从执行上下文栈中弹出"></a>在函数执行完毕后，函数的执行期上下文以及活动对象被删除，函数的执行上下文从执行上下文栈中弹出</h6><h3 id="DOM常见的操作方式"><a href="#DOM常见的操作方式" class="headerlink" title="DOM常见的操作方式"></a>DOM常见的操作方式</h3><h3 id="Array-sort-方法与实现机制"><a href="#Array-sort-方法与实现机制" class="headerlink" title="Array.sort()方法与实现机制"></a>Array.sort()方法与实现机制</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><h5 id="Google-Chrome-V8-插入排序和快速排序"><a href="#Google-Chrome-V8-插入排序和快速排序" class="headerlink" title="Google Chrome V8 插入排序和快速排序"></a>Google Chrome V8 插入排序和快速排序</h5><h5 id="Microsoft-Edge-和-IE-9-Chakra-快速排序"><a href="#Microsoft-Edge-和-IE-9-Chakra-快速排序" class="headerlink" title="Microsoft Edge 和 IE(9+) Chakra 快速排序"></a>Microsoft Edge 和 IE(9+) Chakra 快速排序</h5><h5 id="Mozilla-Firefox-SpiderMonkey-归并排序"><a href="#Mozilla-Firefox-SpiderMonkey-归并排序" class="headerlink" title="Mozilla Firefox SpiderMonkey 归并排序"></a>Mozilla Firefox SpiderMonkey 归并排序</h5><h5 id="Safari-Nitro（JavaScriptCore-）-归并排序和桶排序"><a href="#Safari-Nitro（JavaScriptCore-）-归并排序和桶排序" class="headerlink" title="Safari Nitro（JavaScriptCore ） 归并排序和桶排序"></a>Safari Nitro（JavaScriptCore ） 归并排序和桶排序</h5><h3 id="Ajax的请求过程"><a href="#Ajax的请求过程" class="headerlink" title="Ajax的请求过程"></a>Ajax的请求过程</h3><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><h5 id="1-创建-XMLHttpRequest-对象-也就是创建一个异步调用对象"><a href="#1-创建-XMLHttpRequest-对象-也就是创建一个异步调用对象" class="headerlink" title="(1)创建`XMLHttpRequest`对象,也就是创建一个异步调用对象."></a>(1)创建`XMLHttpRequest`对象,也就是创建一个异步调用对象.</h5><h6 id="IE7-Chrome-Firefox-Safari-Opera执行此代码"><a href="#IE7-Chrome-Firefox-Safari-Opera执行此代码" class="headerlink" title="//IE7+,Chrome,Firefox,Safari,Opera执行此代码"></a>//IE7+,Chrome,Firefox,Safari,Opera执行此代码</h6><p>####### xmlhttp=new XMLHttpRequest;</p>
<h6 id="IE5-IE6执行该代码"><a href="#IE5-IE6执行该代码" class="headerlink" title="//IE5,IE6执行该代码"></a>//IE5,IE6执行该代码</h6><p>####### xmlhttp=new ActiveXObject(“Microsoft.XMLHTTP”);</p>
<h5 id="2-创建一个新的-HTTP-请求-并指定该-HTTP-请求的方法、-URL-及验证信息"><a href="#2-创建一个新的-HTTP-请求-并指定该-HTTP-请求的方法、-URL-及验证信息" class="headerlink" title="(2)创建一个新的`HTTP`请求,并指定该`HTTP`请求的方法、`URL`及验证信息."></a>(2)创建一个新的`HTTP`请求,并指定该`HTTP`请求的方法、`URL`及验证信息.</h5><h6 id="xmlhttp-open-method-url-async"><a href="#xmlhttp-open-method-url-async" class="headerlink" title="xmlhttp.open(method,url,async);"></a>xmlhttp.open(method,url,async);</h6><p>####### method：请求的类型；GET 或 POST</p>
<p>####### url：文件在服务器上的位置，相对位置或绝对位置</p>
<p>####### async：true（异步）或 false（同步）</p>
<p>######## True 表示脚本会在 send() 方法之后继续执行，而不等待来自服务器的响应</p>
<h5 id="3-设置响应-HTTP-请求状态变化的函数"><a href="#3-设置响应-HTTP-请求状态变化的函数" class="headerlink" title="(3)设置响应`HTTP`请求状态变化的函数."></a>(3)设置响应`HTTP`请求状态变化的函数.</h5><h6 id="post请求一定要设置请求头的格式内容"><a href="#post请求一定要设置请求头的格式内容" class="headerlink" title="post请求一定要设置请求头的格式内容"></a>post请求一定要设置请求头的格式内容</h6><p>####### xmlhttp.setRequestHeader(“content-type”,”application/x-www-form-urlencoded”);</p>
<h5 id="4-发送-HTTP-请求"><a href="#4-发送-HTTP-请求" class="headerlink" title="(4)发送`HTTP`请求."></a>(4)发送`HTTP`请求.</h5><h6 id="xmlhttp-send-“fname-Herry-amp-lname-Ford”"><a href="#xmlhttp-send-“fname-Herry-amp-lname-Ford”" class="headerlink" title="xmlhttp.send(“fname=Herry&amp;lname=Ford”);"></a>xmlhttp.send(“fname=Herry&amp;lname=Ford”);</h6><h5 id="5-获取异步调用返回的数据"><a href="#5-获取异步调用返回的数据" class="headerlink" title="(5)获取异步调用返回的数据."></a>(5)获取异步调用返回的数据.</h5><h6 id="xmlhttp-onreadystatechange-function-接收到服务端响应时触发-if-xmlhttp-readyState-4-amp-amp-xmlhttp-status-200-document-getElementById-“mydiv”-innerHTML-xmlhttp-responseText"><a href="#xmlhttp-onreadystatechange-function-接收到服务端响应时触发-if-xmlhttp-readyState-4-amp-amp-xmlhttp-status-200-document-getElementById-“mydiv”-innerHTML-xmlhttp-responseText" class="headerlink" title="xmlhttp.onreadystatechange=function () {//接收到服务端响应时触发 if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200){ document.getElementById(“mydiv”).innerHTML=xmlhttp.responseText; } }"></a>xmlhttp.onreadystatechange=function () {//接收到服务端响应时触发 if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200){ document.getElementById(“mydiv”).innerHTML=xmlhttp.responseText; } }</h6><p>####### 请求状态xmlhttp.readyState</p>
<p>######## 0: 请求未初始化</p>
<p>######## 1: 服务器连接已建立</p>
<p>######## 2: 请求已接收</p>
<p>######## 3: 请求处理中</p>
<p>######## 4: 请求已完成，且响应已就绪</p>
<p>####### xmlhttp.status：响应状态码</p>
<p>######## 200: “OK”</p>
<p>######## 304：该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。</p>
<p>######## 403 （禁止） 服务器拒绝请求。</p>
<p>######## 404 （未找到） 服务器找不到请求的网页。</p>
<p>######## 408 （请求超时） 服务器等候请求时发生超时。</p>
<p>######## 500 （服务器内部错误） 服务器遇到错误，无法完成请求。</p>
<h5 id="6-使用JavaScript和DOM实现局部刷新"><a href="#6-使用JavaScript和DOM实现局部刷新" class="headerlink" title="(6)使用JavaScript和DOM实现局部刷新."></a>(6)使用JavaScript和DOM实现局部刷新.</h5><h6 id="document-getElementById-“mydiv”-innerHTML-xmlhttp-responseText"><a href="#document-getElementById-“mydiv”-innerHTML-xmlhttp-responseText" class="headerlink" title="document.getElementById(“mydiv”).innerHTML=xmlhttp.responseText;"></a>document.getElementById(“mydiv”).innerHTML=xmlhttp.responseText;</h6><h3 id="JS的垃圾回收机制"><a href="#JS的垃圾回收机制" class="headerlink" title="JS的垃圾回收机制"></a>JS的垃圾回收机制</h3><h4 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h4><h5 id="JavaScript-中的内存管理是自动执行的，而且是不可见的"><a href="#JavaScript-中的内存管理是自动执行的，而且是不可见的" class="headerlink" title="JavaScript 中的内存管理是自动执行的，而且是不可见的"></a>JavaScript 中的内存管理是自动执行的，而且是不可见的</h5><h4 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h4><h5 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h5><h6 id="“可达性”-值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中"><a href="#“可达性”-值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中" class="headerlink" title="“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中"></a>“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中</h6><h5 id="回收器"><a href="#回收器" class="headerlink" title="回收器"></a>回收器</h5><h6 id="JavaScript-引擎中有一个后台进程称为垃圾回收器，它监视所有对象，并删除那些不可访问的对象"><a href="#JavaScript-引擎中有一个后台进程称为垃圾回收器，它监视所有对象，并删除那些不可访问的对象" class="headerlink" title="JavaScript 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，并删除那些不可访问的对象"></a>JavaScript 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，并删除那些不可访问的对象</h6><h4 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h4><h5 id="根"><a href="#根" class="headerlink" title="根"></a>根</h5><h6 id="有一组基本的固有可达值，由于显而易见的原因无法删除"><a href="#有一组基本的固有可达值，由于显而易见的原因无法删除" class="headerlink" title="有一组基本的固有可达值，由于显而易见的原因无法删除"></a>有一组基本的固有可达值，由于显而易见的原因无法删除</h6><p>####### 本地函数的局部变量和参数</p>
<p>####### 当前嵌套调用链上的其他函数的变量和参数</p>
<p>####### 全局变量</p>
<p>####### 还有一些其他的，内部的</p>
<h5 id="可达值"><a href="#可达值" class="headerlink" title="可达值"></a>可达值</h5><h6 id="如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的"><a href="#如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的" class="headerlink" title="如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的"></a>如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的</h6><h4 id="特殊-1"><a href="#特殊-1" class="headerlink" title="特殊"></a>特殊</h4><h5 id="相互关联的对象"><a href="#相互关联的对象" class="headerlink" title="相互关联的对象"></a>相互关联的对象</h5><h6 id="输出引用无关紧要。只有传入的对象才能使对象可访问"><a href="#输出引用无关紧要。只有传入的对象才能使对象可访问" class="headerlink" title="输出引用无关紧要。只有传入的对象才能使对象可访问"></a>输出引用无关紧要。只有传入的对象才能使对象可访问</h6><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><h5 id="基本的垃圾回收算法称为”标记-清除”，定期执行以下”垃圾回收”步骤"><a href="#基本的垃圾回收算法称为”标记-清除”，定期执行以下”垃圾回收”步骤" class="headerlink" title="基本的垃圾回收算法称为”标记-清除”，定期执行以下”垃圾回收”步骤"></a>基本的垃圾回收算法称为”标记-清除”，定期执行以下”垃圾回收”步骤</h5><h6 id="垃圾回收器获取根并”标记”-记住-它们。"><a href="#垃圾回收器获取根并”标记”-记住-它们。" class="headerlink" title="垃圾回收器获取根并”标记”(记住)它们。"></a>垃圾回收器获取根并”标记”(记住)它们。</h6><h6 id="然后它访问并”标记”所有来自它们的引用。"><a href="#然后它访问并”标记”所有来自它们的引用。" class="headerlink" title="然后它访问并”标记”所有来自它们的引用。"></a>然后它访问并”标记”所有来自它们的引用。</h6><h6 id="然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。"><a href="#然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。" class="headerlink" title="然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。"></a>然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。</h6><h6 id="以此类推，直到有未访问的引用-可以从根访问-为止。"><a href="#以此类推，直到有未访问的引用-可以从根访问-为止。" class="headerlink" title="以此类推，直到有未访问的引用(可以从根访问)为止。"></a>以此类推，直到有未访问的引用(可以从根访问)为止。</h6><h6 id="除标记的对象外，所有对象都被删除。"><a href="#除标记的对象外，所有对象都被删除。" class="headerlink" title="除标记的对象外，所有对象都被删除。"></a>除标记的对象外，所有对象都被删除。</h6><h5 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h5><h6 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h6><p>####### 对象分为两组:”新对象”和”旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变”老”，并且很少接受检查</p>
<h6 id="增量回收"><a href="#增量回收" class="headerlink" title="增量回收"></a>增量回收</h6><p>####### 如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟</p>
<p>####### 因此，引擎试图将垃圾回收分解为多个部分</p>
<p>######## 然后，各个部分分别执行</p>
<p>####### 这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟</p>
<h6 id="空闲时间收集"><a href="#空闲时间收集" class="headerlink" title="空闲时间收集"></a>空闲时间收集</h6><p>####### 垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响</p>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><h5 id="问什么是垃圾"><a href="#问什么是垃圾" class="headerlink" title="问什么是垃圾"></a>问什么是垃圾</h5><h6 id="一般来说没有被引用的对象就是垃圾，就是要被清除"><a href="#一般来说没有被引用的对象就是垃圾，就是要被清除" class="headerlink" title="一般来说没有被引用的对象就是垃圾，就是要被清除"></a>一般来说没有被引用的对象就是垃圾，就是要被清除</h6><p>####### 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除</p>
<h5 id="如何检垃圾"><a href="#如何检垃圾" class="headerlink" title="如何检垃圾"></a>如何检垃圾</h5><h6 id="一种算法是标记-标记-清除-算法"><a href="#一种算法是标记-标记-清除-算法" class="headerlink" title="一种算法是标记 标记-清除 算法"></a>一种算法是标记 标记-清除 算法</h6><h3 id="19-JS中的String、Array和Math方法"><a href="#19-JS中的String、Array和Math方法" class="headerlink" title="19. JS中的String、Array和Math方法"></a>19. JS中的String、Array和Math方法</h3><h3 id="20-addEventListener和onClick-的区别"><a href="#20-addEventListener和onClick-的区别" class="headerlink" title="20. addEventListener和onClick()的区别"></a>20. addEventListener和onClick()的区别</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h5 id="一个div如果绑定两个onclick事件，那么它只会执行一次"><a href="#一个div如果绑定两个onclick事件，那么它只会执行一次" class="headerlink" title="一个div如果绑定两个onclick事件，那么它只会执行一次"></a>一个div如果绑定两个onclick事件，那么它只会执行一次</h5><h6 id="这个时候就需要addEventListener事件代理出马了"><a href="#这个时候就需要addEventListener事件代理出马了" class="headerlink" title="这个时候就需要addEventListener事件代理出马了"></a>这个时候就需要addEventListener事件代理出马了</h6><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><h5 id="target-addEventListener-type-listener-options"><a href="#target-addEventListener-type-listener-options" class="headerlink" title="target.addEventListener(type, listener, options);"></a>target.addEventListener(type, listener, options);</h5><h6 id="target-目标"><a href="#target-目标" class="headerlink" title="target 目标"></a>target 目标</h6><h6 id="type-类型-比如-点击或者移入移出"><a href="#type-类型-比如-点击或者移入移出" class="headerlink" title="type 类型 比如 点击或者移入移出"></a>type 类型 比如 点击或者移入移出</h6><h6 id="listener-事件本身"><a href="#listener-事件本身" class="headerlink" title="listener 事件本身"></a>listener 事件本身</h6><h6 id="options-（可选写还是不写）是布尔值false冒泡，true是捕获"><a href="#options-（可选写还是不写）是布尔值false冒泡，true是捕获" class="headerlink" title="options （可选写还是不写）是布尔值false冒泡，true是捕获"></a>options （可选写还是不写）是布尔值false冒泡，true是捕获</h6><p>####### 冒泡 是点击子元素，子元素事件先出现</p>
<p>######## 然后出现父元素事件</p>
<p>####### 捕获 是点击子元素，父元素事件先出现</p>
<p>######## 然后出现子元素事件</p>
<p>####### 冒泡捕获 同时进行</p>
<p>######## 父元素捕获=&gt;子元素冒泡=&gt;子元素捕获=&gt;父元素冒泡</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><h5 id="onclick"><a href="#onclick" class="headerlink" title="onclick"></a>onclick</h5><h6 id="1-onclick事件在同一时间只能指向唯一对象"><a href="#1-onclick事件在同一时间只能指向唯一对象" class="headerlink" title="1.onclick事件在同一时间只能指向唯一对象"></a>1.onclick事件在同一时间只能指向唯一对象</h6><h6 id="时差问题"><a href="#时差问题" class="headerlink" title="时差问题"></a>时差问题</h6><p>####### 因为用户可能会在 HTML 元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件</p>
<p>####### 为此，很多 HTML 事件处理程序都会被封装在一个 try- catch 块中，以便错误不会浮出水面，如下面的例子所示</p>
<h6 id="耦合问题"><a href="#耦合问题" class="headerlink" title="耦合问题"></a>耦合问题</h6><p>####### 说明</p>
<p>######## 如果要更换事件处理程序，就要改动两个地方</p>
<p>######### HTML 代码和 JavaScript 代码</p>
<h5 id="add"><a href="#add" class="headerlink" title="add"></a>add</h5><h6 id="2-addEventListener给一个事件注册多个listener"><a href="#2-addEventListener给一个事件注册多个listener" class="headerlink" title="2.addEventListener给一个事件注册多个listener"></a>2.addEventListener给一个事件注册多个listener</h6><h6 id="4-addEventListener可以控制listener的触发阶段，（捕获-冒泡）。对于多个相同的事件处理器，不会重复触发，不需要手动使用removeEventListener清除"><a href="#4-addEventListener可以控制listener的触发阶段，（捕获-冒泡）。对于多个相同的事件处理器，不会重复触发，不需要手动使用removeEventListener清除" class="headerlink" title="4.addEventListener可以控制listener的触发阶段，（捕获/冒泡）。对于多个相同的事件处理器，不会重复触发，不需要手动使用removeEventListener清除"></a>4.addEventListener可以控制listener的触发阶段，（捕获/冒泡）。对于多个相同的事件处理器，不会重复触发，不需要手动使用removeEventListener清除</h6><h6 id="3-addEventListener对任何DOM都是有效的，而onclick仅限于HTML"><a href="#3-addEventListener对任何DOM都是有效的，而onclick仅限于HTML" class="headerlink" title="3.addEventListener对任何DOM都是有效的，而onclick仅限于HTML"></a>3.addEventListener对任何DOM都是有效的，而onclick仅限于HTML</h6><h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><h6 id="5-IE9使用attachEvent和detachEvent"><a href="#5-IE9使用attachEvent和detachEvent" class="headerlink" title="5.IE9使用attachEvent和detachEvent"></a>5.IE9使用attachEvent和detachEvent</h6><h3 id="21-new和Object-create的区别"><a href="#21-new和Object-create的区别" class="headerlink" title="21. new和Object.create的区别"></a>21. new和Object.create的区别</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h5 id="new"><a href="#new" class="headerlink" title="new"></a>new</h5><h6 id="使用new关键字创建对象时，将新对象的-proto-指向构造函数的prototype，使新对象可以访问构造函数的prototype关联的对象的属性"><a href="#使用new关键字创建对象时，将新对象的-proto-指向构造函数的prototype，使新对象可以访问构造函数的prototype关联的对象的属性" class="headerlink" title="使用new关键字创建对象时，将新对象的__proto__指向构造函数的prototype，使新对象可以访问构造函数的prototype关联的对象的属性"></a>使用new关键字创建对象时，将新对象的__proto__指向构造函数的prototype，使新对象可以访问构造函数的prototype关联的对象的属性</h6><h6 id="执行”构造函数”时this指向新对象，从而为新对象创建了属性和方法"><a href="#执行”构造函数”时this指向新对象，从而为新对象创建了属性和方法" class="headerlink" title="执行”构造函数”时this指向新对象，从而为新对象创建了属性和方法"></a>执行”构造函数”时this指向新对象，从而为新对象创建了属性和方法</h6><h5 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h5><h6 id="凭空创建一个新对象并把新对象内部的-Prototype-关联到你指定的对象（本例中是-Foo）"><a href="#凭空创建一个新对象并把新对象内部的-Prototype-关联到你指定的对象（本例中是-Foo）" class="headerlink" title="凭空创建一个新对象并把新对象内部的 [[Prototype]] 关联到你指定的对象（本例中是 Foo）"></a>凭空创建一个新对象并把新对象内部的 [[Prototype]] 关联到你指定的对象（本例中是 Foo）</h6><p>####### 换句话说，这条语句的意思是：”创建一个新的 foo2 对象并把它关联到 Foo”</p>
<h4 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h4><h5 id="使用new创建的对象，通过this引用会获取到属性和方法"><a href="#使用new创建的对象，通过this引用会获取到属性和方法" class="headerlink" title="使用new创建的对象，通过this引用会获取到属性和方法"></a>使用new创建的对象，通过this引用会获取到属性和方法</h5><h6 id="并且该对象与构造函数指向相同的prototype"><a href="#并且该对象与构造函数指向相同的prototype" class="headerlink" title="并且该对象与构造函数指向相同的prototype"></a>并且该对象与构造函数指向相同的prototype</h6><h5 id="使用Object-create-创建的对象是空的，该对象的-prototype-抛弃关联的默认对象，指向Object-create-的参数"><a href="#使用Object-create-创建的对象是空的，该对象的-prototype-抛弃关联的默认对象，指向Object-create-的参数" class="headerlink" title="使用Object.create()创建的对象是空的，该对象的.prototype 抛弃关联的默认对象，指向Object.create()的参数"></a>使用Object.create()创建的对象是空的，该对象的.prototype 抛弃关联的默认对象，指向Object.create()的参数</h5><h5 id="如果参数为null的话，Object-create则会创建空对象"><a href="#如果参数为null的话，Object-create则会创建空对象" class="headerlink" title="如果参数为null的话，Object.create则会创建空对象"></a>如果参数为null的话，Object.create则会创建空对象</h5><h6 id="两者都是创建空对象，但是new创建出的空对象会绑定Object的prototype原型对象，但是Object-create-null-的空对象是没有任何属性的"><a href="#两者都是创建空对象，但是new创建出的空对象会绑定Object的prototype原型对象，但是Object-create-null-的空对象是没有任何属性的" class="headerlink" title="两者都是创建空对象，但是new创建出的空对象会绑定Object的prototype原型对象，但是Object.create(null)的空对象是没有任何属性的"></a>两者都是创建空对象，但是new创建出的空对象会绑定Object的prototype原型对象，但是Object.create(null)的空对象是没有任何属性的</h6><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><h5 id="proto-是Object对象的不可枚举属性，其他对象通过prototype引用该属性，那为什么可以获取当前对象的prototype呢？"><a href="#proto-是Object对象的不可枚举属性，其他对象通过prototype引用该属性，那为什么可以获取当前对象的prototype呢？" class="headerlink" title="__proto__是Object对象的不可枚举属性，其他对象通过prototype引用该属性，那为什么可以获取当前对象的prototype呢？"></a>__proto__是Object对象的不可枚举属性，其他对象通过prototype引用该属性，那为什么可以获取当前对象的prototype呢？</h5><h6 id="因为某一对象在调用该属性时，this已经指向了当前调动该属性的对象（this的隐式调用）"><a href="#因为某一对象在调用该属性时，this已经指向了当前调动该属性的对象（this的隐式调用）" class="headerlink" title="因为某一对象在调用该属性时，this已经指向了当前调动该属性的对象（this的隐式调用）"></a>因为某一对象在调用该属性时，this已经指向了当前调动该属性的对象（this的隐式调用）</h6><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><h5 id="Object-create-proto-propertiesObject"><a href="#Object-create-proto-propertiesObject" class="headerlink" title="Object.create(proto, [ propertiesObject ])"></a>Object.create(proto, [ propertiesObject ])</h5><h6 id="proto是原型对象"><a href="#proto是原型对象" class="headerlink" title="proto是原型对象"></a>proto是原型对象</h6><h6 id="propertiesObject是属性的配置"><a href="#propertiesObject是属性的配置" class="headerlink" title="propertiesObject是属性的配置"></a>propertiesObject是属性的配置</h6><h3 id="22-DOM的location对象"><a href="#22-DOM的location对象" class="headerlink" title="22. DOM的location对象"></a>22. DOM的location对象</h3><h3 id="23-浏览器从输入URL到页面渲染的整个流程（涉及到计算机网络数据传输过程、浏览器解析渲染过程）"><a href="#23-浏览器从输入URL到页面渲染的整个流程（涉及到计算机网络数据传输过程、浏览器解析渲染过程）" class="headerlink" title="23. 浏览器从输入URL到页面渲染的整个流程（涉及到计算机网络数据传输过程、浏览器解析渲染过程）"></a>23. 浏览器从输入URL到页面渲染的整个流程（涉及到计算机网络数据传输过程、浏览器解析渲染过程）</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><h5 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h5><h6 id="浏览器是多进程的，每一个标签页都是一个单独的Renderer进程"><a href="#浏览器是多进程的，每一个标签页都是一个单独的Renderer进程" class="headerlink" title="浏览器是多进程的，每一个标签页都是一个单独的Renderer进程"></a>浏览器是多进程的，每一个标签页都是一个单独的Renderer进程</h6><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><h6 id="Browser-进程"><a href="#Browser-进程" class="headerlink" title="Browser 进程"></a>Browser 进程</h6><p>####### 负责各个标签页的协调控制，网络请求和绘制 Bitmap 到界面上</p>
<h6 id="插件进程"><a href="#插件进程" class="headerlink" title="插件进程"></a>插件进程</h6><p>####### 每种类型的插件对应一个进程，仅当使用该插件时才创建该进程</p>
<h6 id="GPU-进程"><a href="#GPU-进程" class="headerlink" title="GPU 进程"></a>GPU 进程</h6><p>####### 最多只有一个，用于 3D 绘制</p>
<h6 id="Renderer进程"><a href="#Renderer进程" class="headerlink" title="Renderer进程"></a>Renderer进程</h6><p>####### 控制每个标签页的页面渲染（最终在内存上生成 Bitmap），脚本执行，事件处理，定时器进程和异步 Http 请求</p>
<h5 id="Renderer进程-1"><a href="#Renderer进程-1" class="headerlink" title="Renderer进程"></a>Renderer进程</h5><h6 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h6><p>####### GUI渲染线程</p>
<p>######## 负责解析HTML/CSS，构建DOM树/CSS规则树和render树，布局渲染，处理Reflow(回流)和Repaint(重绘)</p>
<p>####### JavaScript引擎线程</p>
<p>######## 负责解释执行JavaScript脚本，我们说JS是单线程的就是指这个JavaScript引擎线程</p>
<p>####### 事件触发线程</p>
<p>######## 该线程不属于JS引擎线程，用来控制事件循环，当对应的事件(如鼠标事件)符合条件被触发时，该线程会把事件添加到待处理事件队列的尾部，等待JS引擎线程的处理</p>
<p>####### 定时触发器线程</p>
<p>######## setInterval和setTimeout所在线程，当计时完毕时会将要处理的逻辑置于事件队列中，等待JS引擎线程的处理</p>
<p>####### 异步Http请求线程</p>
<p>######## 用于AJAX请求，当检测到状态(readyState、status)发生变化时，如果设有回调函数，该线程就会产生状态变换事件，将这个回调函数放入事件队列中，等待JS引擎处理</p>
<h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><p>####### GUI渲染线程与JavaScript引擎线程互斥</p>
<p>######## 当JS引擎线程执行时，GUI线程会被挂起，GUI更新会被保存到事件队列中等待JS引擎线程空闲时执行</p>
<h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h4><h5 id="从URL到网络请求"><a href="#从URL到网络请求" class="headerlink" title="从URL到网络请求"></a>从URL到网络请求</h5><h6 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h6><p>####### 当我们打开空白标签页时，浏览器就创建一个新的Renderer进程</p>
<p>####### 在这之后我们键入URL按下回车，浏览器的Browser主进程会开辟一个网络请求线程用于网络请求</p>
<h6 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h6><p>####### 解析URL的协议名，域名，端口号，路径，查询参数(?)，哈希值(#)等</p>
<h6 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h6><p>####### 首先读取DNS缓存，如果有相应的浏览器缓存或本地缓存，则直接使用缓存，不进行DNS解析</p>
<p>####### 如果没有相应的DNS缓存，则进行DNS解析，查询出域名对应的IP地址</p>
<h6 id="建立TCP-IP连接"><a href="#建立TCP-IP连接" class="headerlink" title="建立TCP/IP连接"></a>建立TCP/IP连接</h6><p>####### 通过三次握手建立与服务器的连接(长连接或短连接)，在此之后发送具体的请求到服务器，等待服务器的响应</p>
<p>####### 浏览器根据请求作出应答，返回数据包</p>
<p>####### 最后当关闭连接时，双方进行通过四次挥手断开连接</p>
<h5 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h5><h6 id="加载解析HTML，开始构建DOM树。"><a href="#加载解析HTML，开始构建DOM树。" class="headerlink" title="加载解析HTML，开始构建DOM树。"></a>加载解析HTML，开始构建DOM树。</h6><h6 id="遇到CSS外链，异步加载解析CSS，构建CSS规则树。"><a href="#遇到CSS外链，异步加载解析CSS，构建CSS规则树。" class="headerlink" title="遇到CSS外链，异步加载解析CSS，构建CSS规则树。"></a>遇到CSS外链，异步加载解析CSS，构建CSS规则树。</h6><h6 id="遇到script标签，如果是普通JS标签则同步加载并执行，阻塞页面渲染，如果标签上有defer-async属性则异步加载JS资源"><a href="#遇到script标签，如果是普通JS标签则同步加载并执行，阻塞页面渲染，如果标签上有defer-async属性则异步加载JS资源" class="headerlink" title="遇到script标签，如果是普通JS标签则同步加载并执行，阻塞页面渲染，如果标签上有defer/async属性则异步加载JS资源"></a>遇到script标签，如果是普通JS标签则同步加载并执行，阻塞页面渲染，如果标签上有defer/async属性则异步加载JS资源</h6><p>####### 设置defer的JS资源会在DOMContentLoaded事件之前执行；设置了async的JS资源加载完就执行</p>
<h6 id="合并DOM树和CSS规则树生成render树。"><a href="#合并DOM树和CSS规则树生成render树。" class="headerlink" title="合并DOM树和CSS规则树生成render树。"></a>合并DOM树和CSS规则树生成render树。</h6><h6 id="布局render树，计算各元素的尺寸、位置等，在内存上生成Bitmap。"><a href="#布局render树，计算各元素的尺寸、位置等，在内存上生成Bitmap。" class="headerlink" title="布局render树，计算各元素的尺寸、位置等，在内存上生成Bitmap。"></a>布局render树，计算各元素的尺寸、位置等，在内存上生成Bitmap。</h6><h6 id="渲染render树，将内存上的Bitmap绘制到屏幕上。"><a href="#渲染render树，将内存上的Bitmap绘制到屏幕上。" class="headerlink" title="渲染render树，将内存上的Bitmap绘制到屏幕上。"></a>渲染render树，将内存上的Bitmap绘制到屏幕上。</h6><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><h5 id="·-onload和DOMContentLoaded"><a href="#·-onload和DOMContentLoaded" class="headerlink" title="· onload和DOMContentLoaded"></a>· onload和DOMContentLoaded</h5><h6 id="DOMContentLoaded指DOM加载完成，不包括样式表、图片，可能此时带有async的js资源没有加载解析完成"><a href="#DOMContentLoaded指DOM加载完成，不包括样式表、图片，可能此时带有async的js资源没有加载解析完成" class="headerlink" title="DOMContentLoaded指DOM加载完成，不包括样式表、图片，可能此时带有async的js资源没有加载解析完成"></a>DOMContentLoaded指DOM加载完成，不包括样式表、图片，可能此时带有async的js资源没有加载解析完成</h6><h6 id="onload触发时所有的DOM，样式表，脚本，图片均已加载完成"><a href="#onload触发时所有的DOM，样式表，脚本，图片均已加载完成" class="headerlink" title="onload触发时所有的DOM，样式表，脚本，图片均已加载完成"></a>onload触发时所有的DOM，样式表，脚本，图片均已加载完成</h6><h5 id="Css"><a href="#Css" class="headerlink" title="Css"></a>Css</h5><h6 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h6><p>####### 因为css资源是通过link标签异步加载的，故css加载和解析均不会影响DOM树的构建</p>
<p>######## 但是如果DOM树构建完成CSS规则树仍未构建完成就会阻塞render树的构建，阻塞页面渲染</p>
<h6 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h6><p>####### 因为标签的解析均是GUI线程的工作，遇到外链不论是同步加载还是异步加载，解析顺序均是标签的顺序</p>
<p>####### link标签位于script标签之前就会先解析link标签去构建CSS规则树，然后再使用JS线程去执行加载得到的JS文件</p>
<h5 id="JS分同步任务和异步任务"><a href="#JS分同步任务和异步任务" class="headerlink" title="JS分同步任务和异步任务"></a>JS分同步任务和异步任务</h5><h6 id="同步任务会在JS引擎线程上形成一个任务栈"><a href="#同步任务会在JS引擎线程上形成一个任务栈" class="headerlink" title="同步任务会在JS引擎线程上形成一个任务栈"></a>同步任务会在JS引擎线程上形成一个任务栈</h6><p>####### 除JS引擎线程之外，事件触发线程管理一个任务队列</p>
<p>####### 只要异步任务有了结果，就会在任务队列中放置一个事件</p>
<h6 id="一旦任务栈中所有同步任务执行完，系统会读取任务队列，将可执行的异步任务添加到可执行栈中去执行"><a href="#一旦任务栈中所有同步任务执行完，系统会读取任务队列，将可执行的异步任务添加到可执行栈中去执行" class="headerlink" title="一旦任务栈中所有同步任务执行完，系统会读取任务队列，将可执行的异步任务添加到可执行栈中去执行"></a>一旦任务栈中所有同步任务执行完，系统会读取任务队列，将可执行的异步任务添加到可执行栈中去执行</h6><h5 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h5><h6 id="DOM结构发生改变-元素的位置、结构、尺寸发生改变-窗口放缩-获取某些属性-如offset、scoll、width等-等会引发回流"><a href="#DOM结构发生改变-元素的位置、结构、尺寸发生改变-窗口放缩-获取某些属性-如offset、scoll、width等-等会引发回流" class="headerlink" title="DOM结构发生改变/元素的位置、结构、尺寸发生改变/窗口放缩/获取某些属性(如offset、scoll、width等)等会引发回流"></a>DOM结构发生改变/元素的位置、结构、尺寸发生改变/窗口放缩/获取某些属性(如offset、scoll、width等)等会引发回流</h6><h6 id="元素一些样式发生的改变不会对布局产生影响时会产生重绘，如背景色，文字颜色等"><a href="#元素一些样式发生的改变不会对布局产生影响时会产生重绘，如背景色，文字颜色等" class="headerlink" title="元素一些样式发生的改变不会对布局产生影响时会产生重绘，如背景色，文字颜色等"></a>元素一些样式发生的改变不会对布局产生影响时会产生重绘，如背景色，文字颜色等</h6><h3 id="24-跨域、同源策略及跨域实现方式和原理"><a href="#24-跨域、同源策略及跨域实现方式和原理" class="headerlink" title="24. 跨域、同源策略及跨域实现方式和原理"></a>24. 跨域、同源策略及跨域实现方式和原理</h3><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><h5 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h5><h6 id="它是由Netscape提出的一个著名的安全策略"><a href="#它是由Netscape提出的一个著名的安全策略" class="headerlink" title="它是由Netscape提出的一个著名的安全策略"></a>它是由Netscape提出的一个著名的安全策略</h6><p>####### 所有支持JavaScript 的浏览器都会使用这个策略</p>
<h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><h6 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h6><p>####### 所谓同源是指，域名，协议，端口相同</p>
<h5 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h5><h6 id="如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问"><a href="#如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问" class="headerlink" title="如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问"></a>如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问</h6><h5 id="说明-8"><a href="#说明-8" class="headerlink" title="说明"></a>说明</h5><h6 id="同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染"><a href="#同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染" class="headerlink" title="同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染"></a>同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染</h6><p>####### 因此拦截的是客户端发出的请求回来的数据接收，即请求发送了，服务器响应了，但是无法被浏览器接收</p>
<h5 id="情况"><a href="#情况" class="headerlink" title="情况"></a>情况</h5><h6 id><a href="#" class="headerlink" title></a></h6><p>####### http和https也属于跨域</p>
<h4 id="跨域的实现方式"><a href="#跨域的实现方式" class="headerlink" title="跨域的实现方式"></a>跨域的实现方式</h4><h5 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h5><h6 id="是的，浏览器遵守同源策略，但是有若干个标签是允许跨域的"><a href="#是的，浏览器遵守同源策略，但是有若干个标签是允许跨域的" class="headerlink" title="是的，浏览器遵守同源策略，但是有若干个标签是允许跨域的"></a>是的，浏览器遵守同源策略，但是有若干个标签是允许跨域的</h6><p>####### <img src="/.dev//xxx" alt></p>
<p>####### <link href="xxx"></p>
<p>####### <script src="xxx"></script></p>
<h6 id="这些标签一般是加载静态资源的，和后端关系不大，我们应该关心如何解决AJAX跨域问题"><a href="#这些标签一般是加载静态资源的，和后端关系不大，我们应该关心如何解决AJAX跨域问题" class="headerlink" title="这些标签一般是加载静态资源的，和后端关系不大，我们应该关心如何解决AJAX跨域问题"></a>这些标签一般是加载静态资源的，和后端关系不大，我们应该关心如何解决AJAX跨域问题</h6><h5 id="解决跨域的方式"><a href="#解决跨域的方式" class="headerlink" title="解决跨域的方式"></a>解决跨域的方式</h5><h6 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h6><p>####### 实现</p>
<p>######## <script> ¶ 标签+show.js</p>
<p>######### 示例</p>
<p>########## <script><br>        function printResponse(data) {<br>            console.log(data);<br>        }<br></script> ¶ <script type="text/javascript" src="/show.js"></script></p>
<p>########## show.js</p>
<p>########### // 调用printResponse()方法，但是这个方法并没有在当前js文件中定义 printResponse(“(“ + “{\n” + &quot; \“username\“: \“bravo\“,\n&quot; + &quot; \“age\“: 18,\n&quot; + &quot; \“address\“: \“China\“\n&quot; + “}” + “)”);</p>
<p>######## 动态 ¶ <script> ¶ +Controller</p>
<p>######### 说明</p>
<p>########## 那么，能不能把这段代码交由Controller作为响应结果直接返回呢</p>
<p>######### 示例</p>
<p>########## <script><br>        // 2.动态拼接<script>标签，请求js片段并调用printResponse()<br>        let url = "<a href="http://localhost:8080/getUser/1&quot;" target="_blank" rel="noopener">http://localhost:8080/getUser/1&quot;</a>;<br>        // 平时都是手写<script src="">，现在我们在代码中动态构造script标签并设置src属性<br>        let script = document.createElement('script');<br>        script.type = "text/javascript";<br>        script.src = url;<br>        // 把script标签加入head（因为script标签本来也是在html的head中），并发起请求，后端响应后浏览器会自动执行返回的script片段<br>        document.getElementsByTagName('head')[0].appendChild(script);<br>    </script></p>
<p>######## 动态 ¶ <script> ¶ +callback+Controller</p>
<p>######### 问题</p>
<p>########## 方案2有个最大的问题是：可扩展性差</p>
<p>####### 特性</p>
<p>######## 优点</p>
<p>######### 它不像XMLHttpRequest 对象实现 Ajax 请求那样受到同源策略的限制</p>
<p>######### 兼容性很好，在古老的浏览器也能很好的运行</p>
<p>######### 不需要 XMLHttpRequest 或 ActiveX 的支持；并且在请求完毕后可以通过调用 callback 的方式回传结果</p>
<p>######## 缺点</p>
<p>######### 它支持 GET 请求而不支持 POST 等其它类行的 HTTP 请求。</p>
<p>########## 最显著的缺点其实是JSONP只支持GET请求，毕竟它的灵感来自于 ¶ <script> ¶ 标签，而标签都是GET请求</p>
<p>######### 它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面或 iframe 之间进行数据通信的问题</p>
<h6 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h6><p>####### 定义</p>
<p>######## CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）</p>
<p>####### 条件</p>
<p>######## CORS需要浏览器和服务器同时支持</p>
<p>######### 在CORS中，浏览器会自动带来一些请求头，后端需要针对这些请求头做一些处理</p>
<p>####### 说明</p>
<p>######## CORS通信与AJAX没有任何差别，因此我们不需要改变以前的业务逻辑</p>
<p>######### 只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否允许其跨域，然后在响应头中加入一些信息即可</p>
<p>####### 使用</p>
<p>######## 方法上加@CrossOrigin</p>
<p>######### @CrossOrigin还可以加载Controller上，这样Controller的所有方法都支持跨域</p>
<p>####### 支持</p>
<p>######## 浏览器认为只要后端没返回CORS头(Access-Control-Allow-Origin)，就认为后端不允许跨域，返回的数据不可靠</p>
<p>######## 所以只要后端能够返回浏览器需要的请求头，即可跨域（响应数据就不会被同源策略抛弃）</p>
<p>####### 特性</p>
<p>######## 优点</p>
<p>######### 使用简单方便，更为安全</p>
<p>######### 支持 POST 请求方式</p>
<p>######## 缺点</p>
<p>######### CORS 是一种新型的跨域问题的解决方案，存在兼容问题，仅支持 IE 10 以上</p>
<h6 id="Server-Proxy"><a href="#Server-Proxy" class="headerlink" title="Server Proxy"></a>Server Proxy</h6><p>####### 理解</p>
<p>######## 当你需要有跨域的请求操作时发送请求给后端，让后端帮你代为请求，然后最后将获取的结果发送给你</p>
<h6 id="Node中间件代理"><a href="#Node中间件代理" class="headerlink" title="Node中间件代理"></a>Node中间件代理</h6><h6 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h6><h3 id="25-浏览器的回流（Reflow）和重绘（Repaints）"><a href="#25-浏览器的回流（Reflow）和重绘（Repaints）" class="headerlink" title="25. 浏览器的回流（Reflow）和重绘（Repaints）"></a>25. 浏览器的回流（Reflow）和重绘（Repaints）</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><h5 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h5><h6 id="由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如outline-visibility-color、background-color等"><a href="#由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如outline-visibility-color、background-color等" class="headerlink" title="由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如outline,visibility,color、background-color等"></a>由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如outline,visibility,color、background-color等</h6><h5 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h5><h6 id="是布局或者几何属性需要改变就称为回流"><a href="#是布局或者几何属性需要改变就称为回流" class="headerlink" title="是布局或者几何属性需要改变就称为回流"></a>是布局或者几何属性需要改变就称为回流</h6><p>####### 回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新</p>
<h6 id="一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流"><a href="#一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流" class="headerlink" title="一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流"></a>一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流</h6><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><h5 id="可以看到left一直在重绘-回流，但是translate就不一样啦，这是因为CSS3做了很多优化"><a href="#可以看到left一直在重绘-回流，但是translate就不一样啦，这是因为CSS3做了很多优化" class="headerlink" title="可以看到left一直在重绘&回流，但是translate就不一样啦，这是因为CSS3做了很多优化"></a>可以看到left一直在重绘&回流，但是translate就不一样啦，这是因为CSS3做了很多优化</h5><h4 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h4><h5 id="解析HTML，生成DOM树，解析CSS，生成CSSOM树"><a href="#解析HTML，生成DOM树，解析CSS，生成CSSOM树" class="headerlink" title="解析HTML，生成DOM树，解析CSS，生成CSSOM树"></a>解析HTML，生成DOM树，解析CSS，生成CSSOM树</h5><h5 id="将DOM树和CSSOM树结合，生成渲染树-Render-Tree"><a href="#将DOM树和CSSOM树结合，生成渲染树-Render-Tree" class="headerlink" title="将DOM树和CSSOM树结合，生成渲染树(Render Tree)"></a>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</h5><h6 id="从DOM树的根节点开始遍历每个可见节点。"><a href="#从DOM树的根节点开始遍历每个可见节点。" class="headerlink" title="从DOM树的根节点开始遍历每个可见节点。"></a>从DOM树的根节点开始遍历每个可见节点。</h6><p>####### 不可见节点</p>
<p>######## 一些不会渲染输出的节点，比如script、meta、link等。</p>
<p>######## 一些通过css进行隐藏的节点。比如display:none</p>
<p>######### 注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。</p>
<h6 id="对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。"><a href="#对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。" class="headerlink" title="对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。"></a>对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。</h6><h6 id="根据每个可见节点以及其对应的样式，组合生成渲染树。"><a href="#根据每个可见节点以及其对应的样式，组合生成渲染树。" class="headerlink" title="根据每个可见节点以及其对应的样式，组合生成渲染树。"></a>根据每个可见节点以及其对应的样式，组合生成渲染树。</h6><h5 id="Layout-回流-根据生成的渲染树，进行回流-Layout-，得到节点的几何信息（位置，大小）"><a href="#Layout-回流-根据生成的渲染树，进行回流-Layout-，得到节点的几何信息（位置，大小）" class="headerlink" title="Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）"></a>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</h5><h5 id="Painting-重绘-根据渲染树以及回流得到的几何信息，得到节点的绝对像素"><a href="#Painting-重绘-根据渲染树以及回流得到的几何信息，得到节点的绝对像素" class="headerlink" title="Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素"></a>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</h5><h5 id="Display-将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客）"><a href="#Display-将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客）" class="headerlink" title="Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客）"></a>Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客）</h5><h4 id="回流-1"><a href="#回流-1" class="headerlink" title="回流"></a>回流</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><h6 id="前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来"><a href="#前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来" class="headerlink" title="前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来"></a>前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来</h6><h6 id="可是我们还需要计算它们在设备视口-viewport-内的确切位置和大小，这个计算的阶段就是回流"><a href="#可是我们还需要计算它们在设备视口-viewport-内的确切位置和大小，这个计算的阶段就是回流" class="headerlink" title="可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流"></a>可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流</h6><h5 id="过程-3"><a href="#过程-3" class="headerlink" title="过程"></a>过程</h5><h6 id="为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历"><a href="#为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历" class="headerlink" title="为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历"></a>为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历</h6><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><h6 id="第一个div将节点的显示尺寸设置为视口宽度的50-，第二个div将其尺寸设置为父节点的50-。而在回流这个阶段"><a href="#第一个div将节点的显示尺寸设置为视口宽度的50-，第二个div将其尺寸设置为父节点的50-。而在回流这个阶段" class="headerlink" title="第一个div将节点的显示尺寸设置为视口宽度的50%，第二个div将其尺寸设置为父节点的50%。而在回流这个阶段"></a>第一个div将节点的显示尺寸设置为视口宽度的50%，第二个div将其尺寸设置为父节点的50%。而在回流这个阶段</h6><h6 id="而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值"><a href="#而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值" class="headerlink" title="而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值"></a>而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值</h6><h4 id="重绘-1"><a href="#重绘-1" class="headerlink" title="重绘"></a>重绘</h4><h5 id="说明-9"><a href="#说明-9" class="headerlink" title="说明"></a>说明</h5><h6 id="最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息-位置、大小"><a href="#最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息-位置、大小" class="headerlink" title="最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)"></a>最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)</h6><h6 id="那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点"><a href="#那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点" class="headerlink" title="那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点"></a>那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点</h6><h4 id="何时发生回流重绘"><a href="#何时发生回流重绘" class="headerlink" title="何时发生回流重绘"></a>何时发生回流重绘</h4><h5 id="回流-2"><a href="#回流-2" class="headerlink" title="回流"></a>回流</h5><h6 id="说明-10"><a href="#说明-10" class="headerlink" title="说明"></a>说明</h6><p>####### 我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流</p>
<h6 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h6><p>####### 添加或删除可见的DOM元素</p>
<p>####### 元素的位置发生变化</p>
<p>####### 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</p>
<p>####### 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</p>
<p>####### 页面一开始渲染的时候（这肯定避免不了）</p>
<p>####### 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</p>
<h4 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h4><h5 id="浏览器的优化机制"><a href="#浏览器的优化机制" class="headerlink" title="浏览器的优化机制"></a>浏览器的优化机制</h5><h6 id="说明-11"><a href="#说明-11" class="headerlink" title="说明"></a>说明</h6><p>####### 由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程</p>
<h6 id="过程-4"><a href="#过程-4" class="headerlink" title="过程"></a>过程</h6><p>####### 浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列</p>
<h6 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h6><p>####### 但是！当你获取布局信息的操作的时候，会强制队列刷新</p>
<p>######## offsetTop、offsetLeft、offsetWidth、offsetHeight</p>
<p>######## scrollTop、scrollLeft、scrollWidth、scrollHeight</p>
<p>######## clientTop、clientLeft、clientWidth、clientHeight</p>
<p>######## getComputedStyle()</p>
<p>######## getBoundingClientRect</p>
<p>####### 优化</p>
<p>######## 我们在修改样式的时候</p>
<p>######### 最好避免使用上面列出的属性，他们都会刷新渲染队列</p>
<p>######### 如果要使用它们，最好将值缓存起来</p>
<h5 id="最小化重绘和重排"><a href="#最小化重绘和重排" class="headerlink" title="最小化重绘和重排"></a>最小化重绘和重排</h5><h6 id="说明-12"><a href="#说明-12" class="headerlink" title="说明"></a>说明</h6><p>####### 由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数</p>
<p>####### 为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉</p>
<h5 id="批量修改DOM"><a href="#批量修改DOM" class="headerlink" title="批量修改DOM"></a>批量修改DOM</h5><h6 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h6><p>####### 使元素脱离文档流</p>
<p>######## 方式</p>
<p>######### 隐藏元素，应用修改，重新显示</p>
<p>######### 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。</p>
<p>######### 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素</p>
<p>####### 对其进行多次修改</p>
<p>####### 将元素带回到文档中</p>
<h5 id="避免触发同步布局事件"><a href="#避免触发同步布局事件" class="headerlink" title="避免触发同步布局事件"></a>避免触发同步布局事件</h5><h6 id="说明-13"><a href="#说明-13" class="headerlink" title="说明"></a>说明</h6><p>####### 上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局</p>
<h5 id="对于复杂动画效果-使用绝对定位让其脱离文档流"><a href="#对于复杂动画效果-使用绝对定位让其脱离文档流" class="headerlink" title="对于复杂动画效果,使用绝对定位让其脱离文档流"></a>对于复杂动画效果,使用绝对定位让其脱离文档流</h5><h6 id="说明-14"><a href="#说明-14" class="headerlink" title="说明"></a>说明</h6><p>####### 否则会引起父元素以及后续元素频繁的回流</p>
<h5 id="css3硬件加速（GPU加速）"><a href="#css3硬件加速（GPU加速）" class="headerlink" title="css3硬件加速（GPU加速）"></a>css3硬件加速（GPU加速）</h5><h6 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h6><p>####### 比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦</p>
<h6 id="说明-15"><a href="#说明-15" class="headerlink" title="说明"></a>说明</h6><p>####### 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘</p>
<p>####### 但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的</p>
<p>######## 不过它还是可以提升这些动画的性能</p>
<h6 id="常见的触发硬件加速的css属性"><a href="#常见的触发硬件加速的css属性" class="headerlink" title="常见的触发硬件加速的css属性"></a>常见的触发硬件加速的css属性</h6><p>####### transform</p>
<p>####### opacity</p>
<p>####### filters</p>
<p>####### Will-change</p>
<h6 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h6><p>####### 如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。</p>
<p>####### 在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同</p>
<p>######## 因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊</p>
<h3 id="26-JavaScript中的arguments"><a href="#26-JavaScript中的arguments" class="headerlink" title="26. JavaScript中的arguments"></a>26. JavaScript中的arguments</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><h5 id="arguments-是一个类数组对象。代表传给一个function的参数列表"><a href="#arguments-是一个类数组对象。代表传给一个function的参数列表" class="headerlink" title="arguments 是一个类数组对象。代表传给一个function的参数列表"></a>arguments 是一个类数组对象。代表传给一个function的参数列表</h5><h6 id="arguments-是一个类数组的对象"><a href="#arguments-是一个类数组的对象" class="headerlink" title="arguments 是一个类数组的对象"></a>arguments 是一个类数组的对象</h6><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><h5 id="arguments-length"><a href="#arguments-length" class="headerlink" title="arguments length"></a>arguments length</h5><h5 id="arguments-转数组"><a href="#arguments-转数组" class="headerlink" title="arguments 转数组"></a>arguments 转数组</h5><h6 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h6><p>####### 类数组转化为数组</p>
<h6 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h6><p>####### 不能将函数的 arguments 泄露或者传递出去</p>
<p>######## 即 return 出去</p>
<p>######### 最终的结果就是 V8 引擎将会跳过优化，导致相当大的性能损失</p>
<h6 id="非数组的原因"><a href="#非数组的原因" class="headerlink" title="非数组的原因"></a>非数组的原因</h6><p>####### arguments 在语言的早期就引入了</p>
<p>######## 当时的 Array 对象具有 4 个方法： toString、 join、 reverse 和 sort</p>
<p>######## arguments 继承于 Object 的很大原因是不需要这四个方法</p>
<p>######### 而现在，Array 添加了很多强大的方法，比如 forEach、map、filter 等等</p>
<p>####### 那为什么现在不在新的版本里让 arguments 重新继承自 Array呢？</p>
<p>######## 其实 ES5 的草案中就包含这一点，但为了向前兼容，最终还是被委员会否决了</p>
<h5 id="修改-arguments-值"><a href="#修改-arguments-值" class="headerlink" title="修改 arguments 值"></a>修改 arguments 值</h5><h6 id="在严格模式与非严格模式下，修改函数参数值表现的结果不一样"><a href="#在严格模式与非严格模式下，修改函数参数值表现的结果不一样" class="headerlink" title="在严格模式与非严格模式下，修改函数参数值表现的结果不一样"></a>在严格模式与非严格模式下，修改函数参数值表现的结果不一样</h6><p>####### function foo(a) {</p>
<p>######## "use strict";</p>
<p>######### arguments[0] = a</p>
<p>######### 但之后各管各</p>
<p>######## 非严格模式</p>
<p>######### a 是 arguments[0] 的引用</p>
<h5 id="将参数从一个函数传递到另一个函数"><a href="#将参数从一个函数传递到另一个函数" class="headerlink" title="将参数从一个函数传递到另一个函数"></a>将参数从一个函数传递到另一个函数</h5><h6 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h6><p>####### function foo() { bar.apply(this, arguments); } function bar(a, b, c) {</p>
<h5 id="arguments-与重载"><a href="#arguments-与重载" class="headerlink" title="arguments 与重载"></a>arguments 与重载</h5><h6 id="说明-16"><a href="#说明-16" class="headerlink" title="说明"></a>说明</h6><p>####### 很多语言中都有重载，但 JavaScript 中没有</p>
<h6 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h6><p>####### 我们可以利用 arguments 模拟重载</p>
<p>######## function add(num1, num2, num3) { if (arguments.length === 2) {</p>
<h4 id="ES6-中的-arguments"><a href="#ES6-中的-arguments" class="headerlink" title="ES6 中的 arguments"></a>ES6 中的 arguments</h4><h5 id="扩展操作符"><a href="#扩展操作符" class="headerlink" title="扩展操作符"></a>扩展操作符</h5><h6 id="console-log-arguments"><a href="#console-log-arguments" class="headerlink" title="console.log(...arguments);"></a>console.log(...arguments);</h6><h5 id="Rest-参数"><a href="#Rest-参数" class="headerlink" title="Rest 参数"></a>Rest 参数</h5><h6 id="function-func-firstArg-restArgs"><a href="#function-func-firstArg-restArgs" class="headerlink" title="function func(firstArg, ...restArgs) {"></a>function func(firstArg, ...restArgs) {</h6><h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><h6 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h6><p>####### function func(firstArg = 0, secondArg = 1) { console.log(arguments[0], arguments[1]); console.log(firstArg, secondArg);</p>
<p>######## 99 undefined</p>
<p>######## 99 1</p>
<h6 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h6><p>####### 默认参数对 arguments 没有影响，arguments 还是仅仅表示调用函数时所传入的所有参数</p>
<h5 id="arguments-转数组-1"><a href="#arguments-转数组-1" class="headerlink" title="arguments 转数组"></a>arguments 转数组</h5><h6 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h6><h4 id="数组与类数组对象"><a href="#数组与类数组对象" class="headerlink" title="数组与类数组对象"></a>数组与类数组对象</h4><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><h6 id="数组具有一个基本特征：索引"><a href="#数组具有一个基本特征：索引" class="headerlink" title="数组具有一个基本特征：索引"></a>数组具有一个基本特征：索引</h6><p>####### 这是一般对象所没有的</p>
<h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><h6 id="Object-与-Array-的唯一区别就是-Object-的索引是-string，而-Array-的索引是-number"><a href="#Object-与-Array-的唯一区别就是-Object-的索引是-string，而-Array-的索引是-number" class="headerlink" title="Object 与 Array 的唯一区别就是 Object 的索引是 string，而 Array 的索引是 number"></a>Object 与 Array 的唯一区别就是 Object 的索引是 string，而 Array 的索引是 number</h6><h5 id="类数组-1"><a href="#类数组-1" class="headerlink" title="类数组"></a>类数组</h5><h6 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h6><p>####### 伪数组的特性就是长得像数组，包含一组数据以及拥有一个 length 属性，但是没有任何 Array 的方法</p>
<p>######## length 属性是个非负整数，上限是 JavaScript 中能精确表达的最大数字</p>
<p>######## 另外，类数组对象的 length 值无法自动改变</p>
<h6 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h6><p>####### 完全方法</p>
<p>######## function Foo() {} Foo.prototype = Object.create(Array.prototype); const foo = new Foo(); foo.push('A'); console.log(foo, foo.length); console.log("foo is an array? " + Array.isArray(foo));</p>
<p>######### ["A"] 1</p>
<p>######### foo is an array? false</p>
<p>########## 也就是说 Foo 的实例拥有 Array 的所有方法，但类型不是 Array</p>
<p>####### 部分方法</p>
<p>######## function Bar() {} Bar.prototype.push = Array.prototype.push; const bar = new Bar(); bar.push('A');</p>
<h3 id="27-EventLoop事件循环"><a href="#27-EventLoop事件循环" class="headerlink" title="27. EventLoop事件循环"></a>27. EventLoop事件循环</h3><h4 id="背景-3"><a href="#背景-3" class="headerlink" title="背景"></a>背景</h4><h5 id="JavaScript-是一门-单线程-的语言：同一时间只能运行一个任务"><a href="#JavaScript-是一门-单线程-的语言：同一时间只能运行一个任务" class="headerlink" title="JavaScript 是一门 单线程 的语言：同一时间只能运行一个任务"></a>JavaScript 是一门 单线程 的语言：同一时间只能运行一个任务</h5><h6 id="即代码执行是同步并且阻塞的"><a href="#即代码执行是同步并且阻塞的" class="headerlink" title="即代码执行是同步并且阻塞的"></a>即代码执行是同步并且阻塞的</h6><p>####### 由于 JS 运行在浏览器的主线程，所以这 30 秒的时间里，整个页面都会处于卡死状态</p>
<h5 id="浏览器提供了一些-JS-引擎不具备的功能：Web-API"><a href="#浏览器提供了一些-JS-引擎不具备的功能：Web-API" class="headerlink" title="浏览器提供了一些 JS 引擎不具备的功能：Web API"></a>浏览器提供了一些 JS 引擎不具备的功能：Web API</h5><h6 id="它包括-DOM-API，setTimeout，HTTP-请求-等等。这些功能都可以帮助我们处理-异步、非阻塞-的操作"><a href="#它包括-DOM-API，setTimeout，HTTP-请求-等等。这些功能都可以帮助我们处理-异步、非阻塞-的操作" class="headerlink" title="它包括 DOM API，setTimeout，HTTP 请求 等等。这些功能都可以帮助我们处理 异步、非阻塞 的操作"></a>它包括 DOM API，setTimeout，HTTP 请求 等等。这些功能都可以帮助我们处理 异步、非阻塞 的操作</h6><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><h5 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h5><h6 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h6><p>####### 当我们调用一个函数时，它会被添加到一个叫做 调用栈 (call stack) 的地方</p>
<p>######## 调用栈是 JS 引擎的一部分，而不是浏览器特有的</p>
<p>######## 本质上它是一个栈，具有 后进先出 （Last In, First Out. 即 LIFO） 的特点</p>
<p>######### 当一个函数调用完成，它就被从调用栈中弹出</p>
<h5 id="说明-17"><a href="#说明-17" class="headerlink" title="说明"></a>说明</h5><h6 id="Event-Loop-会一直检查-Call-Stack-中是否有函数需要执行，如果有，就从栈顶依次执行。同时，如果执行的过程中发现其他函数，继续入栈然后执行"><a href="#Event-Loop-会一直检查-Call-Stack-中是否有函数需要执行，如果有，就从栈顶依次执行。同时，如果执行的过程中发现其他函数，继续入栈然后执行" class="headerlink" title="Event Loop 会一直检查 Call Stack 中是否有函数需要执行，如果有，就从栈顶依次执行。同时，如果执行的过程中发现其他函数，继续入栈然后执行"></a>Event Loop 会一直检查 Call Stack 中是否有函数需要执行，如果有，就从栈顶依次执行。同时，如果执行的过程中发现其他函数，继续入栈然后执行</h6><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><h5 id="背景-4"><a href="#背景-4" class="headerlink" title="背景"></a>背景</h5><h6 id="setTimeout-正是-Web-API-提供的功能之一：它可以让我们延迟一个任务的执行并且不阻塞主线程"><a href="#setTimeout-正是-Web-API-提供的功能之一：它可以让我们延迟一个任务的执行并且不阻塞主线程" class="headerlink" title="setTimeout 正是 Web API 提供的功能之一：它可以让我们延迟一个任务的执行并且不阻塞主线程"></a>setTimeout 正是 Web API 提供的功能之一：它可以让我们延迟一个任务的执行并且不阻塞主线程</h6><h5 id="说明-18"><a href="#说明-18" class="headerlink" title="说明"></a>说明</h5><h6 id="假如我们发起了一个网络请求-request-，或者设置了一个定时器延时-setTimeout-，一段时间后的代码（回调函数）肯定不是直接被加到调用栈吧"><a href="#假如我们发起了一个网络请求-request-，或者设置了一个定时器延时-setTimeout-，一段时间后的代码（回调函数）肯定不是直接被加到调用栈吧" class="headerlink" title="假如我们发起了一个网络请求(request)，或者设置了一个定时器延时(setTimeout)，一段时间后的代码（回调函数）肯定不是直接被加到调用栈吧"></a>假如我们发起了一个网络请求(request)，或者设置了一个定时器延时(setTimeout)，一段时间后的代码（回调函数）肯定不是直接被加到调用栈吧</h6><h5 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h5><h6 id="Event-Table"><a href="#Event-Table" class="headerlink" title="Event Table"></a>Event Table</h6><p>####### 理解</p>
<p>######## Event Table 可以理解成一张 事件-&gt;回调函数 对应表</p>
<p>####### 功能</p>
<p>######## 它就是用来存储 JavaScript 中的异步事件 (request, setTimeout, IO等) 及其对应的回调函数的列表</p>
<h6 id="Event-Queue"><a href="#Event-Queue" class="headerlink" title="Event Queue"></a>Event Queue</h6><p>####### 理解</p>
<p>######## Event Queue 简单理解就是 回调函数 队列，所以它也叫 Callback Queue</p>
<p>####### 功能</p>
<p>######## 当 Event Table 中的事件被触发，事件对应的 回调函数 就会被 push 进这个 Event Queue，然后等待被执行</p>
<h5 id="说明-19"><a href="#说明-19" class="headerlink" title="说明"></a>说明</h5><h6 id="它不停检查-Call-Stack-中是否有任务（也叫栈帧）需要执行，如果没有，就检查-Event-Queue，从中弹出一个任务，放入-Call-Stack-中，如此往复循环"><a href="#它不停检查-Call-Stack-中是否有任务（也叫栈帧）需要执行，如果没有，就检查-Event-Queue，从中弹出一个任务，放入-Call-Stack-中，如此往复循环" class="headerlink" title="它不停检查 Call Stack 中是否有任务（也叫栈帧）需要执行，如果没有，就检查 Event Queue，从中弹出一个任务，放入 Call Stack 中，如此往复循环"></a>它不停检查 Call Stack 中是否有任务（也叫栈帧）需要执行，如果没有，就检查 Event Queue，从中弹出一个任务，放入 Call Stack 中，如此往复循环</h6><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><h5 id="开始，任务先进入-Call-Stack"><a href="#开始，任务先进入-Call-Stack" class="headerlink" title="开始，任务先进入 Call Stack"></a>开始，任务先进入 Call Stack</h5><h5 id="同步任务直接在栈中等待被执行，异步任务从-Call-Stack-移入到-Event-Table-注册"><a href="#同步任务直接在栈中等待被执行，异步任务从-Call-Stack-移入到-Event-Table-注册" class="headerlink" title="同步任务直接在栈中等待被执行，异步任务从 Call Stack 移入到 Event Table 注册"></a>同步任务直接在栈中等待被执行，异步任务从 Call Stack 移入到 Event Table 注册</h5><h5 id="当对应的事件触发（或延迟到指定时间），Event-Table-会将事件回调函数移入-Event-Queue-等待"><a href="#当对应的事件触发（或延迟到指定时间），Event-Table-会将事件回调函数移入-Event-Queue-等待" class="headerlink" title="当对应的事件触发（或延迟到指定时间），Event Table 会将事件回调函数移入 Event Queue 等待"></a>当对应的事件触发（或延迟到指定时间），Event Table 会将事件回调函数移入 Event Queue 等待</h5><h5 id="当-Call-Stack-中没有任务，就从-Event-Queue-中拿出一个任务放入-Call-Stack"><a href="#当-Call-Stack-中没有任务，就从-Event-Queue-中拿出一个任务放入-Call-Stack" class="headerlink" title="当 Call Stack 中没有任务，就从 Event Queue 中拿出一个任务放入 Call Stack"></a>当 Call Stack 中没有任务，就从 Event Queue 中拿出一个任务放入 Call Stack</h5><h4 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h4><h5 id="其中与-Event-Queue-对应的还有一个叫-Job-Queue，它主要是用来执行-Promise-的"><a href="#其中与-Event-Queue-对应的还有一个叫-Job-Queue，它主要是用来执行-Promise-的" class="headerlink" title="其中与 Event Queue 对应的还有一个叫 Job Queue，它主要是用来执行 Promise 的"></a>其中与 Event Queue 对应的还有一个叫 Job Queue，它主要是用来执行 Promise 的</h5><h6 id="这就涉及到-宏任务-macro-task-和-微任务-micro-task-了"><a href="#这就涉及到-宏任务-macro-task-和-微任务-micro-task-了" class="headerlink" title="这就涉及到 宏任务 (macro task) 和 微任务 (micro task) 了"></a>这就涉及到 宏任务 (macro task) 和 微任务 (micro task) 了</h6><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><h5 id="const-foo-gt-console-log-First-const-bar-gt-setTimeout-gt-console-log-Second-500-const-baz-gt-console-log-Third-bar-foo-baz"><a href="#const-foo-gt-console-log-First-const-bar-gt-setTimeout-gt-console-log-Second-500-const-baz-gt-console-log-Third-bar-foo-baz" class="headerlink" title="const foo = () =&gt; console.log("First"); const bar = () =&gt; setTimeout(() =&gt; console.log("Second"), 500); const baz = () =&gt; console.log("Third"); bar(); foo(); baz();"></a>const foo = () =&gt; console.log("First"); const bar = () =&gt; setTimeout(() =&gt; console.log("Second"), 500); const baz = () =&gt; console.log("Third"); bar(); foo(); baz();</h5><h6 id="我们调用了函数-bar。bar-返回了一个-setTimeout-函数。"><a href="#我们调用了函数-bar。bar-返回了一个-setTimeout-函数。" class="headerlink" title="我们调用了函数 bar。bar 返回了一个 setTimeout 函数。"></a>我们调用了函数 bar。bar 返回了一个 setTimeout 函数。</h6><h6 id="setTimeout-中的回调函数被添加到-Web-API，setTimeout-函数和-bar-调用完成被从调用栈弹出。"><a href="#setTimeout-中的回调函数被添加到-Web-API，setTimeout-函数和-bar-调用完成被从调用栈弹出。" class="headerlink" title="setTimeout 中的回调函数被添加到 Web API，setTimeout 函数和 bar 调用完成被从调用栈弹出。"></a>setTimeout 中的回调函数被添加到 Web API，setTimeout 函数和 bar 调用完成被从调用栈弹出。</h6><h6 id="定时器开始，同时函数-foo-被调用，打印出-First。foo-函数返回-undefined。"><a href="#定时器开始，同时函数-foo-被调用，打印出-First。foo-函数返回-undefined。" class="headerlink" title="定时器开始，同时函数 foo 被调用，打印出 First。foo 函数返回 undefined。"></a>定时器开始，同时函数 foo 被调用，打印出 First。foo 函数返回 undefined。</h6><h6 id="函数-baz-被调用，打印出-Third。"><a href="#函数-baz-被调用，打印出-Third。" class="headerlink" title="函数 baz 被调用，打印出 Third。"></a>函数 baz 被调用，打印出 Third。</h6><h6 id="500ms-定时器结束，回调函数被放入任务队列，Event-Loop-检查到调用栈是空的，所以将其取出放在调用栈。"><a href="#500ms-定时器结束，回调函数被放入任务队列，Event-Loop-检查到调用栈是空的，所以将其取出放在调用栈。" class="headerlink" title="500ms 定时器结束，回调函数被放入任务队列，Event Loop 检查到调用栈是空的，所以将其取出放在调用栈。"></a>500ms 定时器结束，回调函数被放入任务队列，Event Loop 检查到调用栈是空的，所以将其取出放在调用栈。</h6><h6 id="回调函数被执行，打印出-Second"><a href="#回调函数被执行，打印出-Second" class="headerlink" title="回调函数被执行，打印出 Second"></a>回调函数被执行，打印出 Second</h6><h4 id="异步宏任务"><a href="#异步宏任务" class="headerlink" title="异步宏任务"></a>异步宏任务</h4><h5 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h5><h6 id="至少4毫秒，定义0也是4毫秒"><a href="#至少4毫秒，定义0也是4毫秒" class="headerlink" title="至少4毫秒，定义0也是4毫秒"></a>至少4毫秒，定义0也是4毫秒</h6><h5 id="DOM-渲染"><a href="#DOM-渲染" class="headerlink" title="DOM 渲染"></a>DOM 渲染</h5><h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><h3 id="28-宏任务与微任务"><a href="#28-宏任务与微任务" class="headerlink" title="28. 宏任务与微任务"></a>28. 宏任务与微任务</h3><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><h4 id="说明-20"><a href="#说明-20" class="headerlink" title="说明"></a>说明</h4><h5 id="js会优先执行宏任务-宏任务可以同时有多个-但会按顺序一个一个执行"><a href="#js会优先执行宏任务-宏任务可以同时有多个-但会按顺序一个一个执行" class="headerlink" title="js会优先执行宏任务 宏任务可以同时有多个 但会按顺序一个一个执行"></a>js会优先执行宏任务 宏任务可以同时有多个 但会按顺序一个一个执行</h5><h6 id="js会优先执行宏任务-宏任务可以同时有多个-但会按顺序一个一个执行-1"><a href="#js会优先执行宏任务-宏任务可以同时有多个-但会按顺序一个一个执行-1" class="headerlink" title="js会优先执行宏任务 宏任务可以同时有多个 但会按顺序一个一个执行"></a>js会优先执行宏任务 宏任务可以同时有多个 但会按顺序一个一个执行</h6><p>####### 如果微任务队列中有指令或方法 那么就会执行</p>
<p>####### 如果没有 则开始执行下一个宏任务 直到所有的宏任务执行完为止</p>
<h5 id="宏任务占用性能"><a href="#宏任务占用性能" class="headerlink" title="宏任务占用性能"></a>宏任务占用性能</h5><h6 id="需要一些较早就准备好的方法-排在最后才执行的时候-又不想新增一个宏任务"><a href="#需要一些较早就准备好的方法-排在最后才执行的时候-又不想新增一个宏任务" class="headerlink" title="需要一些较早就准备好的方法 排在最后才执行的时候 又不想新增一个宏任务"></a>需要一些较早就准备好的方法 排在最后才执行的时候 又不想新增一个宏任务</h6><p>####### 那么就可以把这些方法 一个一个的放在微任务队列里面</p>
<p>####### 在这个宏任务中的代码执行完后 就会执行微任务队列</p>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><h5 id="微任务队列"><a href="#微任务队列" class="headerlink" title="微任务队列"></a>微任务队列</h5><h6 id="Job-Queue"><a href="#Job-Queue" class="headerlink" title="Job Queue"></a>Job Queue</h6><p>####### 优先级高于宏任务队列</p>
<h5 id="定时器模块"><a href="#定时器模块" class="headerlink" title="定时器模块"></a>定时器模块</h5><h6 id="当执行到setTimeout代码，即把任务放入模块当中，并开始计时"><a href="#当执行到setTimeout代码，即把任务放入模块当中，并开始计时" class="headerlink" title="当执行到setTimeout代码，即把任务放入模块当中，并开始计时"></a>当执行到setTimeout代码，即把任务放入模块当中，并开始计时</h6><h6 id="当时间到了以后，将setTimeout任务放入宏任务列表当中"><a href="#当时间到了以后，将setTimeout任务放入宏任务列表当中" class="headerlink" title="当时间到了以后，将setTimeout任务放入宏任务列表当中"></a>当时间到了以后，将setTimeout任务放入宏任务列表当中</h6><h4 id="数据交互"><a href="#数据交互" class="headerlink" title="数据交互"></a>数据交互</h4><h5 id="数据是都可以访问到的"><a href="#数据是都可以访问到的" class="headerlink" title="数据是都可以访问到的"></a>数据是都可以访问到的</h5><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="任务拆分"><a href="#任务拆分" class="headerlink" title="任务拆分"></a>任务拆分</h5><h6 id="通过setTime"><a href="#通过setTime" class="headerlink" title="通过setTime"></a>通过setTime</h6><p>####### 原理</p>
<p>######## 为子任务添加循环的限制</p>
<p>######### 如果未完成，写到setTimeout中继续完成</p>
<h6 id="通过promise-setTime"><a href="#通过promise-setTime" class="headerlink" title="通过promise+setTime"></a>通过promise+setTime</h6><p>####### 原理</p>
<p>######## 直接写到promise中</p>
<p>######### 方便后续用then方法执行后续流程</p>
<p>######## promise中再用setTime包裹任务</p>
<p>######### 让其异步执行</p>
<h6 id="微任务处理"><a href="#微任务处理" class="headerlink" title="微任务处理"></a>微任务处理</h6><p>####### 原理</p>
<p>######## 直接写入promise的then方法当中</p>
<h3 id="29-BOM属性对象方法"><a href="#29-BOM属性对象方法" class="headerlink" title="29. BOM属性对象方法"></a>29. BOM属性对象方法</h3><h3 id="30-函数柯里化及其通用封装"><a href="#30-函数柯里化及其通用封装" class="headerlink" title="30. 函数柯里化及其通用封装"></a>30. 函数柯里化及其通用封装</h3><h3 id="31-JS的map-和reduce-方法"><a href="#31-JS的map-和reduce-方法" class="headerlink" title="31. JS的map()和reduce()方法"></a>31. JS的map()和reduce()方法</h3><h3 id="32-和-的区别"><a href="#32-和-的区别" class="headerlink" title="32. "=="和"==="的区别"></a>32. "=="和"==="的区别</h3><h3 id="33-setTimeout用作倒计时为何会产生误差？"><a href="#33-setTimeout用作倒计时为何会产生误差？" class="headerlink" title="33. setTimeout用作倒计时为何会产生误差？"></a>33. setTimeout用作倒计时为何会产生误差？</h3><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="1-let、const和var的概念与区别"><a href="#1-let、const和var的概念与区别" class="headerlink" title="1. let、const和var的概念与区别"></a>1. let、const和var的概念与区别</h3><h3 id="2-变量提升与暂时性死区"><a href="#2-变量提升与暂时性死区" class="headerlink" title="2. 变量提升与暂时性死区"></a>2. 变量提升与暂时性死区</h3><h3 id="3-变量的结构赋值"><a href="#3-变量的结构赋值" class="headerlink" title="3. 变量的结构赋值"></a>3. 变量的结构赋值</h3><h3 id="4-箭头函数及其this问题"><a href="#4-箭头函数及其this问题" class="headerlink" title="4. 箭头函数及其this问题"></a>4. 箭头函数及其this问题</h3><h3 id="5-Symbol概念及其作用"><a href="#5-Symbol概念及其作用" class="headerlink" title="5. Symbol概念及其作用"></a>5. Symbol概念及其作用</h3><h3 id="6-Set和Map数据结构"><a href="#6-Set和Map数据结构" class="headerlink" title="6. Set和Map数据结构"></a>6. Set和Map数据结构</h3><h3 id="7-Proxy"><a href="#7-Proxy" class="headerlink" title="7. Proxy"></a>7. Proxy</h3><h3 id="8-Reflect对象"><a href="#8-Reflect对象" class="headerlink" title="8. Reflect对象"></a>8. Reflect对象</h3><h3 id="9-Promise（手撕Promise-A-规范、Promise-all、Promise相关API和方法）"><a href="#9-Promise（手撕Promise-A-规范、Promise-all、Promise相关API和方法）" class="headerlink" title="9. Promise（手撕Promise A+规范、Promise.all、Promise相关API和方法）"></a>9. Promise（手撕Promise A+规范、Promise.all、Promise相关API和方法）</h3><h3 id="10-Iterator和for-of（Iterator遍历器的实现）"><a href="#10-Iterator和for-of（Iterator遍历器的实现）" class="headerlink" title="10. Iterator和for...of（Iterator遍历器的实现）"></a>10. Iterator和for...of（Iterator遍历器的实现）</h3><h3 id="11-循环语法比较及使用场景（for、forEach、for-in、for-of）"><a href="#11-循环语法比较及使用场景（for、forEach、for-in、for-of）" class="headerlink" title="11. 循环语法比较及使用场景（for、forEach、for...in、for...of）"></a>11. 循环语法比较及使用场景（for、forEach、for...in、for...of）</h3><h3 id="12-Generator及其异步方面的应用"><a href="#12-Generator及其异步方面的应用" class="headerlink" title="12. Generator及其异步方面的应用"></a>12. Generator及其异步方面的应用</h3><h3 id="13-async函数"><a href="#13-async函数" class="headerlink" title="13. async函数"></a>13. async函数</h3><h3 id="14-几种异步方式的比较（回调、setTimeout、Promise、Generator、async）"><a href="#14-几种异步方式的比较（回调、setTimeout、Promise、Generator、async）" class="headerlink" title="14. 几种异步方式的比较（回调、setTimeout、Promise、Generator、async）"></a>14. 几种异步方式的比较（回调、setTimeout、Promise、Generator、async）</h3><h3 id="15-class基本语法及继承"><a href="#15-class基本语法及继承" class="headerlink" title="15. class基本语法及继承"></a>15. class基本语法及继承</h3><h3 id="16-模块加载方案比较（CommonJS和ES6的Module）"><a href="#16-模块加载方案比较（CommonJS和ES6的Module）" class="headerlink" title="16. 模块加载方案比较（CommonJS和ES6的Module）"></a>16. 模块加载方案比较（CommonJS和ES6的Module）</h3><h3 id="17-ES6模块加载与CommonJS加载的原理"><a href="#17-ES6模块加载与CommonJS加载的原理" class="headerlink" title="17. ES6模块加载与CommonJS加载的原理"></a>17. ES6模块加载与CommonJS加载的原理</h3><h2 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="在函数执行的时候会在函数内部创建两个变量，arguments，this"><a href="#在函数执行的时候会在函数内部创建两个变量，arguments，this" class="headerlink" title="在函数执行的时候会在函数内部创建两个变量，arguments，this"></a>在函数执行的时候会在函数内部创建两个变量，arguments，this</h4><h4 id="arguments储存着实参的一个类数组对象"><a href="#arguments储存着实参的一个类数组对象" class="headerlink" title="arguments储存着实参的一个类数组对象"></a>arguments储存着实参的一个类数组对象</h4><h4 id="this指向函数执行的上下文"><a href="#this指向函数执行的上下文" class="headerlink" title="this指向函数执行的上下文"></a>this指向函数执行的上下文</h4><h5 id="谁调用这个函数，this就指向谁"><a href="#谁调用这个函数，this就指向谁" class="headerlink" title="谁调用这个函数，this就指向谁"></a>谁调用这个函数，this就指向谁</h5></script></p>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.zackyule.workers.dev/2020/04/21/Js%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="ck9dm8vmq0003ag0v78167ibx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-我的第一篇文章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/21/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" class="article-date">
  <time datetime="2020-04-21T00:56:31.000Z" itemprop="datePublished">2020-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/21/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/">我的第一篇文章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.zackyule.workers.dev/2020/04/21/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" data-id="ck9dm8vms0005ag0v1whq197z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/24/%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95/">图床测试</a>
          </li>
        
          <li>
            <a href="/2020/04/22/t3/">t3</a>
          </li>
        
          <li>
            <a href="/2020/04/22/test2/">test2</a>
          </li>
        
          <li>
            <a href="/2020/04/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/">我的第二篇文章</a>
          </li>
        
          <li>
            <a href="/2020/04/22/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//code.jquery.com/jquery-2.0.3.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>